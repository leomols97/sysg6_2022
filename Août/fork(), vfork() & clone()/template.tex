 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University/School Laboratory Report
% LaTeX Template
% Version 4.0 (March 21, 2022)
%
% This template originates from:
% https://www.LaTeXTemplates.com
%
% Authors:
% Léopold Mols
% Linux and Unix Users Group at Virginia Tech Wiki
%
% License:
% CC BY-NC-SA 4.0 (https://creativecommons.org/licenses/by-nc-sa/4.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[a4paper,17pt]{extarticle} 
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{blindtext}
\usepackage{biblatex}
\usepackage{selinput}
\usepackage{csquotes}
\usepackage[pro]{fontawesome5}
\usepackage[bookmarks,bookmarksnumbered]{hyperref}
\hypersetup{
    colorlinks = true,
    linkcolor = blue,
    anchorcolor = red,
    citecolor = blue}
\AddToHook{cmd/section/before}{\clearpage}
%\usepackage{hyperref}
%\AddToHook{cmd/subsection/before}{\clearpage}

\lstset{
  aboveskip=3mm,
  belowskip=-2mm,
  basicstyle=\footnotesize,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  deletekeywords={...},
  escapeinside={\%*}{*)},
  extendedchars=true,
  framexleftmargin=16pt,
  framextopmargin=3pt,
  framexbottommargin=6pt,
  frame=tb,
  keepspaces=true,
  language=C,
  literate=
  {²}{{\textsuperscript{2}}}1
  {⁴}{{\textsuperscript{4}}}1
  {⁶}{{\textsuperscript{6}}}1
  {⁸}{{\textsuperscript{8}}}1
  {€}{{\euro{}}}1
  {é}{{\'e}}1
  {è}{{\`{e}}}1
  {ê}{{\^{e}}}1
  {ë}{{\¨{e}}}1
  {É}{{\'{E}}}1
  {Ê}{{\^{E}}}1
  {û}{{\^{u}}}1
  {ù}{{\`{u}}}1
  {â}{{\^{a}}}1
  {à}{{\`{a}}}1
  {á}{{\'{a}}}1
  {ã}{{\~{a}}}1
  {Á}{{\'{A}}}1
  {Â}{{\^{A}}}1
  {Ã}{{\~{A}}}1
  {ç}{{\c{c}}}1
  {Ç}{{\c{C}}}1
  {õ}{{\~{o}}}1
  {ó}{{\'{o}}}1
  {ô}{{\^{o}}}1
  {Õ}{{\~{O}}}1
  {Ó}{{\'{O}}}1
  {Ô}{{\^{O}}}1
  {î}{{\^{i}}}1
  {Î}{{\^{I}}}1
  {í}{{\'{i}}}1
  {Í}{{\~{Í}}}1,
  morekeywords={*,...},
  numbers=left,
  numbersep=10pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stepnumber=1,
  tabsize=4,
  title=\lstname,
}

%----------------------------------------------------------------------------------------
%	Début du rapport
%----------------------------------------------------------------------------------------

\title{fork() \\ vfork() \\ clone()} % Report title

\author{Léopold \textsc{Mols}} % Author name(s), add additional authors like: '\& James \textsc{Smith}'

\date{\today}

\begin{document}

\maketitle % Insert the title, author and date using the information specified above

\begin{center}
	\begin{tabular}{l r}
		Année: & SYSG6 Q2 2021-2022 \\ % Date the experiment was performed
		Professeur: & Mme \textsc{Bastreghi} % Professeur/supervisor
	\end{tabular}
\end{center}

\tableofcontents

\section{Que sont-ils ?}
fork() (cfr \ref{definitionFORK} : \textit{fork()}), vfork() (cfr \ref{definitionVFORK} : \textit{vfork()}), clone() (cfr \ref{definitionCLONE} : \textit{clone()}) permettent de créer des processus s'exécutant.
\\\\
Au démarrage d'un système Unix, un seul processus existe (numéro 1). Tous les autres processus qui peuvent exister au cours de la vie du système descendent de ce premier processus, appelé init, via des appels système comme fork, vfork, forkx(), forkall(), forkallx(), vforkx() ou d'autres moyens sont des appels système standard d'UNIX (norme POSIX) permettant de créer des processus (si l'on atteint le nombre maximum de processus s'exécutant pour un même utilisateur (le kernel n'a pas de limite), si la mémoire est pleine et ne peut pas être vidée,...).


%-------------------------------------------------------------------------
%	FORK()
%-------------------------------------------------------------------------

\section{
    \LARGE
        fork()
}\label{fork()}

\subsection{Qu'est-ce}\label{definitionFORK}
\textbf{fork()} crée un nouveau processus en dupliquant le processus appelant.\\
\\Le nouveau processus est appelé processus enfant. L'appel processus est appelé 'processus parent' ou 'père'. Le 'processus enfant' ou 'fils' et le processus parent s'exécutent dans une mémoire séparée. Au moment de \textbf{fork()}, les deux espaces mémoire ont le même contenu. \\Écritures en mémoire, mappages de fichiers (mmap()) et démappages (munmap()) exécutés par l'un des processus n'affecte pas l'autre.

\subsection{Déclaration de fork(2)}
\begin{lstlisting}
#include <unistd.h>

pid_t fork(void);
\end{lstlisting}

\subsection{Historique}
Sur les premiers UNIX (1969 $\rightarrow$ années 1990), seul l'appel système fork permet de créer de nouveaux processus.
La fonction fork fait partie des appels système standard d'UNIX (norme POSIX (Portable Operating System Interface et le X exprime l'héritage UNIX) qui est une famille de normes techniques définie depuis 1988 par l'Institute of Electrical and Electronics Engineers (IEEE), et formellement désignée par IEEE 1003. Ces normes ont émergé d'un projet de standardisation des interfaces de programmation des logiciels destinés à fonctionner sur les variantes du système d'exploitation UNIX).

\subsection{Fonctionnement}
L'appel système fork fournit une valeur résultat qui est entière. Pour différencier le père du fils, il suffit de regarder la valeur de retour du fork() qui peut être :
\begin{itemize}
  \item le PID du fils, auquel cas nous sommes dans le processus père
  \item 0 auquel cas nous sommes dans le processus fils.
  \item -1 qui témoigne une erreur lors de l’exécution de la commande, aucun processus enfant n'est créé et errno est modifié pour indiquer l'erreur.
\end{itemize}

Il est possible d’interagir entre processus de plusieurs manières différentes. Premièrement, on peut envoyer des signaux. En langage de commande kill <pid> permet de tuer le processus ayant pour pid ce que l'on entre dans la commande.
Il est possible de faire attendre un processus grâce à sleep(n) pour bloquer le processus pendant n secondes, ou en utilisant pause() qui bloque jusqu'à la réception d'un signal.
Pour mettre fin à un processus, on peut utiliser exit(state) sachant que state est un code de fin, par convention 0 si ok, code d'erreur sinon.
Il peut être très pratique que le père attende la fin de l'un de ses fils, pour ce faire on utilise pid\_t wait(int *ptr\_state) qui donne comme valeur de retour le pid du fils qui a terminé, et le code de fin est stocké dans ptr\_state.
On peut également attendre la fin du fils grâce à son pid : pid\_t waitpid(pid\_t pid, int *ptr\_state, int options).
Un terme commun dans la partie "Système" de l'informatique est ce que l'on appelle les processus zombies. Cela arrive quand le processus est terminé mais que le père n'a pas attendu son fils, c'est-à-dire qu'il n'a pas fait d'appels à wait(). C'est une situation qu'il convient d'éviter absolument car le processus ne peut plus s'exécuter mais consomme encore des ressources. 

\newpage
\subsection{particularités}
\begin{itemize}
    \item
        \begin{description}
            \item[L'espace d'adressage] est dupliqué, mais uniquement lors de la première modification de ressource grâce à la méthode COW (Copy On Write).
            \\\\La méthode COW trouve son utilisation principale dans le partage de la mémoire virtuelle des processus du système d'exploitation : dans la mise en œuvre de l'appel système de bifurcation. Typiquement, le processus ne modifie aucune mémoire et exécute immédiatement un nouveau processus, remplaçant complètement l'espace d'adressage. Ainsi, il serait inutile de copier toute la mémoire du processus pendant une bifurcation, et au lieu de cela, la technique COW est utilisée.
            \\La méthode COW peut être mise en œuvre efficacement en utilisant le tableau des pages en marquant certaines pages de mémoire comme étant en lecture seule et en comptant le nombre de références à la page. Lorsque des données sont écrites sur ces pages, le noyau du système d'exploitation intercepte la tentative d'écriture et alloue une nouvelle page physique initialisée avec les données de COW, bien que l'allocation puisse être ignorée s'il n'y a qu'une seule référence. Le noyau met ensuite à jour la table des pages avec la nouvelle page, décrémente le nombre de références et effectue l'écriture. La nouvelle allocation garantit qu'un changement dans la mémoire d'un processus n'est pas visible dans un autre.
            \\La technique de COW peut être étendue pour prendre en charge une allocation efficace de mémoire en ayant une page de mémoire physique remplie de zéros. Lorsque la mémoire est allouée, toutes les pages renvoyées se réfèrent à la page de zéros et sont toutes marquées COW. De cette façon, la mémoire physique n'est pas allouée pour le processus tant que les données ne sont pas écrites, ce qui permet aux processus de réserver plus de mémoire virtuelle que de mémoire physique et d'utiliser la mémoire avec modération, au risque de manquer d'espace d'adressage virtuel. L'algorithme combiné est similaire à la pagination à la demande.
        \end{description}
    \item
        \begin{description}
            \item[Le processus enfant] est une copie exacte du processus parent sauf pour
            \begin{itemize}
                \item[$\ast$] L'enfant a son propre ID de processus, ID unique
                \item[$\ast$] L'enfant n'hérite pas des threads de son père et n'en crée pas de nouveaux.
                \\('cat /proc/\$PID/status' -> section 'Threads' ou 'Thr')
                \item[$\ast$] L'enfant n'hérite pas des verrous de mémoire de son parent : \\ipcs -s (A MONTRER)
                \\('ps -aux' pour voir que l'état du père est 'SLl+'. Le 'L' indique que ses pages sont verrouillées en mémoire. L'état du fils indique qu'il n'a pas de pages verrouillées en mémoire.).
                \item[$\ast$] La table des signaux est remise à 0 pour l'enfant : ceci peut être faux en fonction de l'environnement.
%                \item[$\ast$] L'enfant n'hérite pas des sémaphores de son parent.
%                \item[$\ast$] L'enfant n'hérite pas des verrous d'enregistrement associés au processus parent
%                \item[$\ast$] L'enfant n'hérite pas des minuteries de son parent 
%                \item[$\ast$] L'enfant n'hérite pas des E/S asynchrones en suspens ni des contextes d'E/S asynchrones de son parent
                \item[$\ast$] Quelques autres exceptions qui ne sont pas prouvables sur n'importe quel environnement...
            \end{itemize}
        \end{description}
\end{itemize}

\subsection{Problèmes éventuels}
Au vu du fait que fork duplique l'espace d'adressage et d'autres fonctionnement du parent (comme les threads,...), cela peut vite remplir la mémoire, ralentir l'ordinateur et empêcher la création de nouveaux processus si, par exemple, la mémoire est pleine et qu'elle contient des pages qui ne peuvent être supprimées.
\\\\fork() a donné aux créateurs d'Unix la possibilité de déplacer toute cette complexité du kernel-land vers le user-land, où il est beaucoup plus facile de développer des logiciels. Cela les a rendus plus productifs, peut-être beaucoup plus. Le prix que les créateurs d'Unix ont payé pour cette élégance était la nécessité de copier les espaces d'adressage. Étant donné qu'à l'époque, les programmes et les processus étaient petits, l'inélégance était facile à négliger ou à ignorer. Mais maintenant, les processus ont tendance à être énormes et multithreads, ce qui rend extrêmement coûteux la copie même de l'ensemble résident d'un parent et la manipulation de la table des pages pour le reste.

\subsection{Suppléments}
fork1(), forkall(), forkx(), forkallx()
Les fonctions forkx() et forkallx() acceptent un argument flags composé d'un OU inclusif au niveau du bit de zéro ou plusieurs des drapeaux suivants, qui sont définis dans l'en-tête sys/fork.h
Si l'argument flags est 0, forkx() est identique à fork() et forkallx() est identique à forkall().

\subsection{Code}
\begin{normalsize}
Ce code effectue une addition de 2 variables par le fils pour prouver que seules les variables du fils sont modifiées puisque le père et le fils ne partagent pas le même espace d'adressage.
\\Il prouve également que les threads créés par le père ne sont pas transmis au fils ou recréés pour être attribués au fils.
\\ Enfin, il prouve que les verrous de mémoire ne sont pas transmis au fils.
\end{normalsize}

\begin{lstlisting}
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <pthread.h>
#include <mm_malloc.h>
#include <spawn.h>
#include <sys/mman.h>
#include <signal.h>
#include <ctype.h>
#include <string.h>



// Pour compiler avec les threads :
// gcc -pthread -o fork fork.c



void continueProgram()
{
	printf("Pour continuer le programme, entrez 'continue' ou 'c' : ");
	int c, numberCounter = 0, letterCounter = 0;
	while ((c = getchar()) != 'c')
    		if (isalpha(c))
        		letterCounter++;
    		else if (isdigit(c))
        		numberCounter++;
}

int lock_memory(char * address, size_t size)
{
	//https://linuxhint.com/mlock-2-c-function/
	unsigned long page_offset, page_size;
	page_size = sysconf(_SC_PAGE_SIZE);
	page_offset = (unsigned long) address % page_size;
	address -= page_offset; // ajuste l'adresse à la limite de la page
	size += page_offset; // ajuste la taille avec l'offset de la page
	return (mlock(address, size));
}

int unlock_memory(char * address, size_t size)
{
	//https://linuxhint.com/mlock-2-c-function/
	unsigned long page_offset, page_size;
	page_size = sysconf(_SC_PAGE_SIZE);
	page_offset = (unsigned long) address % page_size;
	address -= page_offset; // ajuste l'adresse à la limite de la page
	size += page_offset; // ajuste la taille avec l'offset de la page
	return (munlock(address, size));
}

void signal_handler(int signal_nb)
{
	printf("\nChange le numéro d'un signal\n");
	signal(SIGINT, SIG_DFL);
}

// Fonction exécutée comme un thread
// lorsque son nom est présent comme argument dans l'appel 'pthread_create'
void *threadCreation(void *arg)
{
    printf("Fonction liée à la création de thread appelée \n");
    sleep(50); // Ceci pour permettre d'avoir le temps de prouver que le fils n'hérite pas des threads du père ni en crée de nouveaux
    return NULL;
}

/**
 * Le FORK duplique l'espace d'adressage.
 * Donc, le process créé par FORK fera les additions de son côté.
 *  Ensuite, le fils sera exit, donc, il n'affichera pas le résultat de ses additions
 *
 * Du côté du père, l'addition ne sera pas faite puisqu'il exécutera seulement le code suivant le "if"
 *
 * Vu que l'espace d'adressage est dupliqué lors du FORK, les variables ne seront modifiées que dans
 *  l'espace d'adressage du FILS.
 *  Donc, les variablses du père ne sont pas modifiées
 */
int main(int argc, char **argv) {
    printf("\n\n\n\nCODES D'ÉTAT DE PROCESSUS \nVoici les différentes valeurs que les indicateurs de sortie s, stat et state (en-tête "STAT" ou "S") afficheront pour décrire l'état d'un processus :\n\n"

               "D    en sommeil non interruptible (normalement entrées et sorties) ;\n"
               "R    s'exécutant ou pouvant s'exécuter (dans la file d'exécution) ;\n"
               "S    en sommeil interruptible (en attente d'un événement pour finir) ;\n"
               "T    arrêté, par un signal de contrôle des tâches ou parce qu'il a été tracé ;\n"
               "W    pagination (non valable depuis le noyau 2.6.xx) ;\n"
               "X    tué (ne devrait jamais être vu) ;\n"
               "Z    processus zombie (<defunct>), terminé mais pas détruit par son parent.\n\n"

       "Pour les formats BSD et quand le mot-clé stat est utilisé, les caractères supplémentaires suivants peuvent être affichés :\n\n"

               "<    haute priorité (prioritaire par rapport aux autre utilisateurs) ;\n"
               "N    basse priorité (non prioritaire par rapport aux autres utilisateurs) ;\n"
               "L    les pages du processus sont verrouillées en mémoire;\n"
               "s    meneur de session ;\n"
               "l    possède plusieurs processus légers ("multi-thread", utilisant CLONE_THREAD comme NPTL pthreads le fait) ;\n"
               "+    dans le groupe de processus au premier plan.\n\n\n\n\n\n\n");
               
               
               
    // Entiers à incrémenter dans le fils pour prouver l'espace d'adressage commun
    int a = 5, b = 8;
    // Récupérer la valeur de retour de la fonction créant le proocess fils
    int forkRetNum;
    
    printf("PID du père = %d\n", getpid());
    printf ("Ces 2 variables sont créées par le père :\n");
    printf("a = %d\n", a);
    printf("b = %d\n", b);
    
    // A tester sur les machines de l'école : il faut que la quantité de mémoire allouée au process fils soit différente de celle allouée au process père
    int dataSize = 2048;
    char dataLock[dataSize];
    if (lock_memory(dataLock, dataSize) == -1)
    	perror("Error with locking memory\n");
    else
    	printf ("\nDe la mémoire a été réservée en RAM par le père\n");

    	
    /*signal(SIGINT, signal_handler);
    sleep(30);
    for(int i=1; ; i++)
    {
   	printf("%d, Le programme est dans la fonction main\n", i);
    	sleep(1);
    }*/
    
    continueProgram();
    
    printf("\nCeci est avant que le père ne crée un thread\n\n");
    continueProgram();
    
    int i;
    pthread_t tid;
    // Let us create three threads
    for (i = 0; i < 3; i++)
        pthread_create(&tid, NULL, threadCreation, (void *)&tid);
 
    printf("%s", "");
    
    forkRetNum = fork();
        
    if(forkRetNum == 0) { // La création du fils s'est-elle correctement produite ?
        printf("Le processus fils vient d'être créé. La suite est affichée par le fils.\n");
        // a = 10 but only the one of the chile. not the one of the parent
        a = a + 5;
        printf("Maintenant, a = %d et ce, uniquement dans l'espace d'adressage du fils\n", a);

        // b = 10 but only the one of the chile. not the one of the parent
        b = b + 2;
        printf("Maintenant, b = %d et ce, uniquement dans l'espace d'adressage du fils\n", b);

	//lock_memory();

        printf("PID (du fils, donc) = %d\n", getpid());
        printf("PID du père = %d\n", getppid());
        printf("a + b = %d.\n", a + b);
        printf("\nDans une autre fenêtre de terminal, entrez la commande 'ps' pour voir quel process est en cours et plus d'informations à leurs propos !\n\n");
        printf("Sous la section 'Status', vous pouvez voir que le statut du père est 'SLl+'. Le 'L' signifie que de la mémoire est verrouillée en RAM par le process !\n\n");
        printf("RSS signifie Resident Set Size et montre la quantité de RAM utilisée au moment de la sortie de la commande. "
        	"Il convient également de noter qu'il affiche toute la pile de mémoire physiquement allouée.\n\n");
        printf("VSZ est l'abréviation de Virtual Memory Size. C'est la quantité totale de mémoire à laquelle un processus peut hypothétiquement accéder. "
                "Il tient compte de la taille du binaire lui-même, de toutes les bibliothèques liées et de toutes les allocations de pile ou de tas.\n");
        printf("\n\nDans une autre fenêtre de terminal, entrez la commande 'cat /proc/$PID/status' pour voir les informations du process !\n");
        
        printf("\n\nLe fils est en train de tourner à l'infini via un 'while(1)' pour prouver qu'il n'est pas en sommeil (cfr 'ps'). Pour l'arrêter, dans une autre fenêtre de terminal, entrez la commande 'kill $PID' !\n");
        
        //continueProgram();
        while(1){} // Faire en sorte que le fils attende, mais en étant en état d'exécution. Un simple ps le montrera
        exit(0);
    }
    else if (forkRetNum > 0)
    {  // Est-ce le process parent ?
        printf("Ceci est le process parent et le PID est : %d\n", getpid());
    }
    else
    { // Y a-t-il eu une erreur lors de la création du process fils ?
        printf("Problème durant la duplication\n");
        exit(EXIT_FAILURE);
    }
    // Parent code
    wait(0); // Pour éviter de faire du fils un zombie
    printf ("Le fils est terminé\n");
    printf("PID = %d\n", getpid());
    printf("PPID = %d\n", getppid());
    // La somme est bien de 13 et non plus ni moins puisque la somme fut faite par le fils, mais uniquement avec ses propres variables et non celles du père
    printf("a + b = %d.\n", a + b);
    printf("Vu que a + b = 20 dans le fils et que a + b = 13 dans le père, cela prouve que l'espace d'adressage d'un process créé au moyen de fork n'est pas celui du père car il a été dupliqué par rapport à celui du père. Chaque process a donc ses propres variables,...\n");
    printf("Let's do a ps to see which process is currenlty running !");
    
    if (unlock_memory(dataLock, dataSize) == -1)
    	perror("Error with locking memory\n");
    else
    	printf ("Memory unlocked in RAM\n");
    	
    printf ("\n\nLe programme ne se termine pas pour laisser le temps de faire un ps et voir quels process sont en cours d'exécution. Pour le terminer, faites un 'kill $PID' dans une autre fenêtre de terminal ou faites un CTRL + C\n");
        
    pthread_join(tid, NULL);
    printf("After Thread\n");
  
    while(1){} // Simplement pour faire attendre le père que l'on fasse un ps pour pouvoir voir son état
  
    exit(0);
}
\end{lstlisting}
\subsection{Resultat}
\begin{lstlisting}
CODES D'ÉTAT DE PROCESSUS 
Voici les différentes valeurs que les indicateurs de sortie s, stat et state (en-tête "STAT" ou "S") afficheront pour décrire l'état d'un processus :

D    en sommeil non interruptible (normalement entrées et sorties) ;
R    s'exécutant ou pouvant s'exécuter (dans la file d'exécution) ;
S    en sommeil interruptible (en attente d'un événement pour finir) ;
T    arrêté, par un signal de contrôle des tâches ou parce qu'il a été tracé ;
W    pagination (non valable depuis le noyau 2.6.xx) ;
X    tué (ne devrait jamais être vu) ;
Z    processus zombie (<defunct>), terminé mais pas détruit par son parent.

Pour les formats BSD et quand le mot-clé stat est utilisé, les caractères supplémentaires suivants peuvent être affichés :

<    haute priorité (non poli pour les autres utilisateurs) ;
N    basse priorité (poli pour les autres utilisateurs) ;
L    les pages du processus sont verrouillées en mémoire;
s    meneur de session ;
l    possède plusieurs processus légers ("multi-thread", utilisant CLONE_THREAD comme NPTL pthreads le fait) ;
+    dans le groupe de processus au premier plan.






PID du père = 9059
Ces 2 variables sont créées par le père :
a = 5
b = 8

De la mémoire a été réservée en RAM par le père
Pour continuer le programme, entrez 'continue' ou 'c' : c

Ceci est avant que le père ne crée un thread

Pour continuer le programme, entrez 'continue' ou 'c' : c
Fonction liée à la création de thread appelée 
Fonction liée à la création de thread appelée 
Fonction liée à la création de thread appelée 
Fonction liée à la création de thread appelée 
Le processus fils vient d'être créé. La suite est affichée par le fils.
Ceci est le process parent et le PID est : 9059
Maintenant, a = 10 et ce, uniquement dans l'espace d'adressage du fils
Maintenant, b = 10 et ce, uniquement dans l'espace d'adressage du fils
PID (du fils, donc) = 9063
PID du père = 9059
a + b = 20.

Dans une autre fenêtre de terminal, entrez la commande 'ps' pour voir quel process est en cours et plus d'informations à leurs propos !

Sous la section 'Status', vous pouvez voir que le statut du père est 'SLl+'. Le 'L' signifie que de la mémoire est verrouillée en RAM par le process !

RSS signifie Resident Set Size et montre la quantité de RAM utilisée au moment de la sortie de la commande. Il convient également de noter qu'il affiche toute la pile de mémoire physiquement allouée.

VSZ est l'abréviation de Virtual Memory Size. C'est la quantité totale de mémoire à laquelle un processus peut hypothétiquement accéder. Il tient compte de la taille du binaire lui-même, de toutes les bibliothèques liées et de toutes les allocations de pile ou de tas.


Dans une autre fenêtre de terminal, entrez la commande 'cat /proc/$PID/status' pour voir les informations du process !


Le fils est en train de tourner à l'infini via un 'while(1)' pour prouver qu'il n'est pas en sommeil (cfr 'ps'). Pour l'arrêter, dans une autre fenêtre de terminal, entrez la commande 'kill $PID' !
Le fils est terminé
PID = 9059
PPID = 3532
a + b = 13.
Vu que a + b = 20 dans le fils et que a + b = 13 dans le père, cela prouve que l'espace d'adressage d'un process créé au moyen de fork n'est pas celui du père car il a été dupliqué par rapport à celui du père. Chaque process a donc ses propres variables,...
Let's do a ps to see which process is currenlty running !Memory unlocked in RAM


Le programme ne se termine pas pour laisser le temps de faire un ps et voir quels process sont en cours d'exécution. Pour le terminer, faites un 'kill $PID' dans une autre fenêtre de terminal ou faites un CTRL + C
After Thread
^C

\end{lstlisting}

 
 
 
 
 
%-------------------------------------------------------------------------
%	VFORK()
%-------------------------------------------------------------------------
\newpage
\section{
    \LARGE
        vfork()
}\label{vfork()}

\subsection{Qu'est-ce}\label{definitionVFORK}
\textbf{vfork()} est un appel système ou fonction qui crée un nouveau processus. La fonction \textbf{vfork()} a le même effet que \textbf{fork()}, sauf que le comportement n'est pas défini si le processus créé par \textbf{vfork()} tente d'appeler toute autre fonction avant d'appeler \_exit() ou une des fonctions de la famille exec().
\\\textbf{vfork()} est un cas particulier de \textbf{clone()} que nous verrons plus tard. Il est utilisé pour créer de nouveaux processus sans copier les tables de pages du processus parent. \textbf{vfork()} diffère de \textbf{fork()} car le père appelant est suspendu jusqu'à ce que l'enfant se termine, ou il fait un appel à une fonction de la famille exec(2). Jusqu'à ce moment-là, l'enfant partage toute la mémoire avec son parent.  Il peut être utile dans les applications qui doivent utiliser le minimum des ressources du système. Le processus enfant créé appelle alors immédiatement une fonction de la famille exec() pour se dissocier du père, ce qui changera le statut du père de "en pause" à "en exécution". L'appel \textbf{vfork()} ne diffère de \textbf{fork()} que dans le traitement de l'espace d'adressage virtuel, comme décrit ci-dessus. Les signaux envoyés au parent arrivent après que l'enfant ait libéré la mémoire du parent (c'est-à-dire après sa fin ou après l'appel de à une fonction de la famille exec()).
\\\\Sous Linux, \textbf{fork()} est implémenté en utilisant des pages copy-on-write, donc la seule pénalité encourue par \textbf{fork()} est le temps et la mémoire nécessaire pour dupliquer les tables de pages du parent et pour créer un structure de tâches unique pour l'enfant. Cependant, auparavant, \textbf{fork()} nécessitait de faire une copie complète du l'espace d'adressage du père, souvent inutilement, car généralement immédiatement par la suite, un appel à une fonction de la famille exec() est effectué. Ainsi, pour une plus grande efficacité, BSD a introduit l'appel système \textbf{vfork()}, qui ne copie pas entièrement l"espace d'adressage du père, mais emprunte la mémoire et le fil d'exécution jusqu'à un appel à execve(2) ou une sortie. Le processus parent est suspendu pendant que l'enfant utilise ses ressources. L'utilisation de \textbf{vfork()} a été délicate: par exemple, ne pas modifier les données dans le processus père dépendait de savoir quelles variables étaient conservées dans un registre et lesquelles ne l'étaient dans le but de savoir lesquelles il était autorisé de modifier.


\subsection{Déclaration de vfork(2)}
\begin{lstlisting}
#include <sys/types.h> 
#include <unistd.h>

pid_t vfork(void);
\end{lstlisting}

\subsection{Historique}
L'appel système vfork() est apparu dans BSD 3.0. Dans BSD 4.4, il est devenu synonyme de fork(). NetBSD l'a réintroduit pour qu'il foncitonne à nouveau en tant que vfork() : voir \\url{http://www.netbsd.org/Documentation/kernel/vfork.html}.
\\\\Sous Linux, il fut l'équivalent de fork() jusqu'au noyau 2.2.0-pre-6. Depuis le 2.2.0-pre-9 il s'agit d'un appel système indépendant. Le support dans la bibliothèque a été introduit dans la glibc 2.0.112.
\subsection{Fonctionnement}
Suite à la duplication de processus via \textbf{vfork()}, l’espace d’adressage du fils n’est pas une duplication de celui du père comme pour un fork(), mais il sera le même : celui du père. Cela peut permettre de faire en sorte que, si la duplication du processus fils s'est correctement déroulée, le père n’aura plus d'utilité parce que le fils aura le même espace d'adressage (cfr. la famille d'exec qui remplace l'espace d'adressage du père lors de leur création).
\\\\\textbf{vfork()}, tout comme \textbf{fork()}, crée un processus fils à partir du processus appelant.
\textbf{vfork()} est conçu comme un cas particulier de \textbf{clone()}. Il sert à créer un nouveau processus sans effectuer de copie de la table des pages mémoire du processus père. Ceci peut être utile dans des applications nécessitant une grande rapidité d'exécution, si le fils doit invoquer immédiatement un appel execve().
\\\\\textbf{vfork()} diffère aussi de \textbf{fork()} car le processus père reste en pause jusqu'à ce que le fils invoque execve(), ou \_exit(). Le fils partage toute la mémoire avec son père, y compris la pile, jusqu'à ce que execve() soit appelé par le fils. Le processus fils ne doit donc pas retourner du père. 
\\\\Donc semblable à l'appel système fork(), vfork() crée également un processus enfant identique à son processus parent. Cependant, le processus enfant suspend temporairement le processus parent jusqu'à ce qu'il se termine. En effet, les deux processus utilisent le même espace d'adressage, qui contient la pile, le pointeur de pile et le pointeur d'instructions.


\subsection{particularités}
\begin{itemize}
    \item
        \begin{description}
            \item[L'espace d'adressage] est dupliqué
            \end{description}
    \item
        \begin{description}
            \item[Le processus enfant] est un duplicata exact du processus qui appelle vfork() (le processus parent), à l'exception de ce qui suit :
        \end{description}
        \begin{itemize}
            \item[$\ast$] Le processus enfant a un ID de processus (PID) unique, qui ne correspond à aucun ID de groupe de processus actif.
            \item[$\ast$] L'enfant n'hérite pas des threads de son père et n'en crée pas de nouveaux.
            \\('cat /proc/\$PID/status' -> section 'Threads' ou 'Thr')
        \end{itemize}
\end{itemize}
Toutes les pages de manuel vfork(2) vues indiquent que le processus parent est arrêté jusqu'à ce que l'enfant quitte/exécute, mais cela est antérieur aux threads. Linux, par exemple, n'arrête que le seul thread du parent qui a appelé vfork(), pas tous les threads du père.

\subsection{Problèmes éventuels}
\texttt{A PARLER SUR POWERPOINT}
\\\\Il est regrettable que Linux ait ressuscité ce spectre du passé. La page de manuel de BSD indique que cet appel système sera supprimé quand des mécanismes de partage appropriés seront implémentés, et qu'il ne faut pas essayer de tirer profit du partage mémoire induit par vfork(), car dans ce cas, le système fera qu'il se comportera comme fork(2).
\\\\Les détails de la gestion des signaux sont compliqués, et varient suivant les systèmes.
\\\\\texttt{A PARLER SUR POWERPOINT}
\\\\Lors de l'utilisation de vfork(), il arrive souvent que ce message apparaisse lors de la compilation, ce qui montre, par exemple, que l'exécution diffère d'un système à un autre :
\textit{This system call is deprecated. In a future release, it may begin to return errors in all cases, or may be removed entirely.  It is extremely strongly recommended to replace all uses with fork(2) or, ideally, posix\_spawn(3).} Il indique que vfork() est déprécié (malgré le fait que Linux l'ait ressucité) et qu'il vaut mieux utiliser posix\_spawn puisqu'il est considéré comme son successeur.
\\\\\texttt{A PARLER SUR POWERPOINT}
\\\\vfork() a un inconvénient : le parent (en particulier : le thread dans le parent qui appelle vfork()) et l'enfant partagent une pile, ce qui nécessite que le parent (thread) soit arrêté jusqu'à ce que l'enfant appelle \_exit() ou une fonction de la famille exec(). (Cela peut être pardonné en raison des longs threads précédents de vfork(2) -- lorsque les threads sont apparus, le besoin d'une pile séparée pour chaque nouveau thread est devenu tout à fait clair et inévitable. La solution pour les threads était d'utiliser une nouvelle pile).


\subsection{Code prouvant l'espace d'adressage partagé}
\begin{normalsize}
Ce code effectue une addition de 2 variables par le fils pour prouver que les variables du père sont modifiées par le fils puisque le père et le fils partagent le même espace d'adressage.
\\Il prouve également que les threads créés par le père ne sont pas transmis au fils ou recréés pour être attribués au fils.
\end{normalsize}

\begin{lstlisting}
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <mm_malloc.h>
#include <spawn.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <signal.h>


// gcc -o vfork vfork.c
// Pour compiler avec les threads : gcc -pthread -o vfork vfork.c



// Cette fonction permet à l'utilisateur de choisir à quel moment reprendre
// l'exécution du programme pour lui laisser le temps de faire les manipulations qu'il désire
void continueProgram()
{
	printf("Pour continuer le programme, entrez 'continue' ou 'c' : ");
	int c, numberCounter = 0, letterCounter = 0;
	while ((c = getchar()) != 'c')
    		if (isalpha(c))
        		letterCounter++;
    		else if (isdigit(c))
        		numberCounter++;
}

// Cette fonction a pour but d'être exécutée
// lorsque son nom est spécifié comme argument dans pthread_create()
void *threadCreation(void *arg)
{
    printf("Fonction liée à la création de thread appelée \n");
    sleep(50); // Ceci pour permettre d'avoir le temps de prouver que le fils n'hérite pas des threads du père ni en crée de nouveaux
    return NULL;
}

/**
 * Le VFORK ne duplique pas l'espace d'adressage du père.
 * Donc, le VFORK fera les additions de son côté, mais dans l'espace d'adressage du PERE.
 *
 * Du côté du père, l'addition sera faite puisqu'il partage l'espace d'adressage avec le FILS.
 *
 * Vu que l'espace d'adressage est dupliqué lors du VFORK, les variables seront modifiées dans l'espace d'adressage du PERE (qui est aussi celui du fils)
 *  Donc, les variables du père sont modifiées, ce qui permet la prise en compte de la modification des valeurs des variables, modifications faites par le fils
 */
int main(int argc, char **argv)
{
    printf("\n\n\n\nCODES D'ÉTAT DE PROCESSUS \nVoici les différentes valeurs que les indicateurs de sortie s, stat et state (en-tête "STAT" ou "S") afficheront pour décrire l'état d'un processus :\n\n"

               "D    en sommeil non interruptible (normalement entrées et sorties) ;\n"
               "R    s'exécutant ou pouvant s'exécuter (dans la file d'exécution) ;\n"
               "S    en sommeil interruptible (en attente d'un événement pour finir) ;\n"
               "T    arrêté, par un signal de contrôle des tâches ou parce qu'il a été tracé ;\n"
               "W    pagination (non valable depuis le noyau 2.6.xx) ;\n"
               "X    tué (ne devrait jamais être vu) ;\n"
               "Z    processus zombie (<defunct>), terminé mais pas détruit par son parent.\n\n"

       "Pour les formats BSD et quand le mot-clé stat est utilisé, les caractères supplémentaires suivants peuvent être affichés :\n\n"

               "<    haute priorité (non poli pour les autres utilisateurs) ;\n"
               "N    basse priorité (poli pour les autres utilisateurs) ;\n"
               "L    les pages du processus sont verrouillées en mémoire;\n"
               "s    meneur de session ;\n"
               "l    possède plusieurs processus légers ("multi-thread", utilisant CLONE_THREAD comme NPTL pthreads le fait) ;\n"
               "+    dans le groupe de processus au premier plan.\n\n\n\n\n\n\n");
               
               
               
    // Entiers à incrémenter dans le fils pour prouver l'espace d'adressage commun
    int a = 5, b = 8;
    // Récupérer la valeur de retour de la fonction créant le proocess fils
    int vforkRetNum;

    printf("PID du père = %d\n", getpid());
    printf ("Ces 2 variables sont créées et initialisées par le père :\n");
    printf("a = %d\n", a);
    printf("b = %d\n", b);
    
    continueProgram();
    
    printf("\nCeci est avant que le père ne crée un thread\n\n");
    
    continueProgram();
    
    pthread_t tid;
    // Let us create three threads
    for (unsigned int i = 0; i < 3; i++)
        pthread_create(&tid, NULL, threadCreation, (void *)&tid);
 
    printf("%s", "");
    
    vforkRetNum = vfork();
    
    if(vforkRetNum == 0)
    { // La création du fils s'est-elle correctement produite ?
        printf("Le processus fils vient d'être créé. La suite est affichée par le fils.\n");
        // a = 10
        a = a + 5;
        printf("Maintenant, a = %d et ce, dans l'espace d'adressage du fils qui est aussi celui du père\n", a);

        // b = 10
        b = b + 2;
        printf("Maintenant, b = %d et ce, dans l'espace d'adressage du fils qui est aussi celui du père\n", b);
        
        printf("PID (du fils, donc) = %d\n", getpid());
        printf("PID du père = %d\n", getppid());
//        printf("Value of vfork is %d.\n", vforkRetNum); // Indiquer la valeur de retour de la fonciton créant le process
        printf("a + b = %d.\n", a + b); // line b
        printf("\nDans une autre fenêtre de terminal, entrez la commande 'ps -aux' pour voir quel process est en cours et plus d'informations à leurs propos !\n\n");
	printf("Sous la section 'Status', vous pouvez voir que le statut du père est 'SLl+'.\nLe 'L' signifie que de la mémoire est verrouillée en RAM par le process !\nLe 'l' signifie que le proccess possède plusieurs processus légers : les threads qu'il a créés\n\n");
        printf("RSS signifie Resident Set Size et montre la quantité de RAM utilisée au moment de la sortie de la commande. "
        	"Il convient également de noter qu'il affiche toute la pile de mémoire physiquement allouée.\n\n");
        printf("VSZ est l'abréviation de Virtual Memory Size. C'est la quantité totale de mémoire à laquelle un processus peut hypothétiquement accéder. "
                "Il tient compte de la taille du binaire lui-même, de toutes les bibliothèques liées et de toutes les allocations de pile ou de tas.\n");
        printf("\n\nDans une autre fenêtre de terminal, entrez la commande 'cat /proc/$PID/status' pour voir les informations du process !\n");
        
        // wait est un processus bloquant. Donc, la suite ne sera pas exécutée tant qu'une condition ne sera pas remplie. Si l'on met un pointeur d'un nombre, alors, on pourra récupérer le code de terminaison du processus enfant. Pareil pour exit
        
        printf("\n\nLe fils est en train de tourner à l'infini via un 'while(1)' pour prouver qu'il n'est pas en sommeil (cfr 'ps -aux'). Pour l'arrêter, dans une autre fenêtre de terminal, entrez la commande 'kill $PID' !\n");
        while(1){} // Faire en sorte que le fils attende, mais en étant en état d'exécution. Un simple 'ps -aux' le montrera
        exit(0);
    }
    else if (vforkRetNum > 0)
    {  // Est-ce le process parent ?
        printf("Ceci est le process parent et le PID est : %d\n", getpid());
    }
    else
    { // Y a-t-il eu une erreur lors de la création du process fils ?
        printf("Problème durant le vfork\n");
        exit(EXIT_FAILURE);
    }
    
    wait(0); // Pour éviter de faire du fils un zombie
    printf ("Le fils est terminé\n");
    printf("PID (du père, donc) = %d\n", getpid());
    printf("PPID = %d\n", getppid());
    // La somme est bien de 20 puisque la somme fut faite par le fils avec les mêmes variables que celles du père
    printf("a + b = %d.\n", a + b);
    printf("Vu que a + b = 20 dans le fils et que a + b = 20 dans le père, cela prouve que l'espace d'adressage d'un process créé au moyen de vfork est celui du père car il est partagé avec le père.\n");
    printf("\nDans une autre fenêtre de terminal, entrez la commande 'ps -aux' pour voir quel process est en cours et plus d'informations à leurs propos !\n\n");
    
    printf ("\n\nLe programme ne se termine pas pour laisser le temps de faire un 'ps -aux' et voir quels process sont en cours d'exécution. Pour le terminer, faites un 'kill $PID' dans une autre fenêtre de terminal ou faites un CTRL + C\n");
        
    pthread_join(tid, NULL);
    printf("After Thread\n");
    
    while(1){} // Simplement pour faire attendre le père que l'on fasse un 'ps -aux' pour pouvoir voir son état
    exit(0);
}
\end{lstlisting}
\subsection{Résultat}
\begin{lstlisting}
CODES D'ÉTAT DE PROCESSUS 
Voici les différentes valeurs que les indicateurs de sortie s, stat et state (en-tête "STAT" ou "S") afficheront pour décrire l'état d'un processus :

D    en sommeil non interruptible (normalement entrées et sorties) ;
R    s'exécutant ou pouvant s'exécuter (dans la file d'exécution) ;
S    en sommeil interruptible (en attente d'un événement pour finir) ;
T    arrêté, par un signal de contrôle des tâches ou parce qu'il a été tracé ;
W    pagination (non valable depuis le noyau 2.6.xx) ;
X    tué (ne devrait jamais être vu) ;
Z    processus zombie (<defunct>), terminé mais pas détruit par son parent.

Pour les formats BSD et quand le mot-clé stat est utilisé, les caractères supplémentaires suivants peuvent être affichés :

<    haute priorité (non poli pour les autres utilisateurs) ;
N    basse priorité (poli pour les autres utilisateurs) ;
L    les pages du processus sont verrouillées en mémoire;
s    meneur de session ;
l    possède plusieurs processus légers ("multi-thread", utilisant CLONE_THREAD comme NPTL pthreads le fait) ;
+    dans le groupe de processus au premier plan.






PID du père = 16307
Ces 2 variables sont créées et initialisées par le père :
a = 5
b = 8
Pour continuer le programme, entrez 'continue' ou 'c' : c

Ceci est avant que le père ne crée un thread

Pour continuer le programme, entrez 'continue' ou 'c' : c
Fonction liée à la création de thread appelée 
Fonction liée à la création de thread appelée 
Fonction liée à la création de thread appelée 
Le processus fils vient d'être créé. La suite est affichée par le fils.
Maintenant, a = 10 et ce, dans l'espace d'adressage du fils qui est aussi celui du père
Maintenant, b = 10 et ce, dans l'espace d'adressage du fils qui est aussi celui du père
PID (du fils, donc) = 16312
PID du père = 16307
a + b = 20.

Dans une autre fenêtre de terminal, entrez la commande 'ps -aux' pour voir quel process est en cours et plus d'informations à leurs propos !

Sous la section 'Status', vous pouvez voir que le statut du père est 'SLl+'.
Le 'L' signifie que de la mémoire est verrouillée en RAM par le process !
Le 'l' signifie que le proccess possède plusieurs processus légers : les threads qu'il a créés

RSS signifie Resident Set Size et montre la quantité de RAM utilisée au moment de la sortie de la commande. Il convient également de noter qu'il affiche toute la pile de mémoire physiquement allouée.

VSZ est l'abréviation de Virtual Memory Size. C'est la quantité totale de mémoire à laquelle un processus peut hypothétiquement accéder. Il tient compte de la taille du binaire lui-même, de toutes les bibliothèques liées et de toutes les allocations de pile ou de tas.


Dans une autre fenêtre de terminal, entrez la commande 'cat /proc/$PID/status' pour voir les informations du process !


Le fils est en train de tourner à l'infini via un 'while(1)' pour prouver qu'il n'est pas en sommeil (cfr 'ps -aux'). Pour l'arrêter, dans une autre fenêtre de terminal, entrez la commande 'kill $PID' !
^[[ACeci est le process parent et le PID est : 16307
Le fils est terminé
PID (du père, donc) = 16307
PPID = 3126
a + b = 20.
Vu que a + b = 20 dans le fils et que a + b = 20 dans le père, cela prouve que l'espace d'adressage d'un process créé au moyen de vfork est celui du père car il est partagé avec le père.

Dans une autre fenêtre de terminal, entrez la commande 'ps -aux' pour voir quel process est en cours et plus d'informations à leurs propos !



Le programme ne se termine pas pour laisser le temps de faire un 'ps -aux' et voir quels process sont en cours d'exécution. Pour le terminer, faites un 'kill $PID' dans une autre fenêtre de terminal ou faites un CTRL + C
Terminated

\end{lstlisting}
\subsection{Code prouvant que le parent est mis en pause}
\begin{normalsize}
Ce code effectue un affichage par le père et par le fils. Le fait que le fils effectue le sien en premier et le père en second prouve que le père est mis en pause.
\end{normalsize}
\begin{lstlisting}
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

/**
 vfork() affiche le contenu du 'if{} else{}' deux fois, d'abord dans l'enfant, puis dans le parent.
 Vu que les deux processus partagent le même espace d'adressage, la première sortie contient la valeur du PID correspondant au process fils.
 Dans le bloc if else, le processus fils est exécuté EN PREMIER car il bloque le processus parent lors de son exécution, donc, le père est MIS EN PAUSE.
 */
int main()
{

    printf("\n\n\nvfork() affiche le contenu du 'if{} else{}' deux fois, d'abord dans l'enfant, puis dans le parent.\n"
        "Vu que les deux processus partagent le même espace d'adressage, la première sortie contient la valeur du PID correspondant au process fils.\n"
        "Dans le bloc if else, le processus fils est exécuté EN PREMIER car il bloque le processus parent lors de son exécution, donc, le père est MIS EN PAUSE.\n\n\n");
    //pid_t pid = vfork();  // Crée le process fils

    printf("Process fils avant le 'if{} else{}': %d\n", getpid());

    pid_t pid = vfork();  // Crée le process fils
    
    if (pid > 0)
    {  // Est-ce le process fils ?
        printf("Ceci est le process parent et le PID est : %d\n", getpid());
        exit(0);
    }
    else if (pid == 0)
    {  // Est-ce le process parent ?
        printf("Ceci est le process fils et le PID est : %d\n\n", getpid());

    }
    else
    { // Y a-t-il eu une erreur lors de la création du process fils ?
        printf("Problème durant le fork\n");
        exit(EXIT_FAILURE);
    }
    return 0;
}

\end{lstlisting}
\subsection{Résultat}
\begin{lstlisting}

vfork() affiche le contenu du 'if{} else{}' deux fois, d'abord dans l'enfant, puis dans le parent.
Vu que les deux processus partagent le même espace d'adressage, la première sortie contient la valeur du PID correspondant au process fils.
Dans le bloc if else, le processus fils est exécuté EN PREMIER car il bloque le processus parent lors de son exécution, donc, le père est MIS EN PAUSE.


Process fils avant le 'if{} else{}': 14839
Ceci est le process fils et le PID est : 14840
Ceci est le process parent et le PID est : 14839

\end{lstlisting}







%-------------------------------------------------------------------------
%	CLONE()
%-------------------------------------------------------------------------
\newpage
\section{
    \LARGE
        clone()
}\label{clone()}

\subsection{Qu'est-ce}\label{definitionCLONE}
\textbf{clone()} crée un nouveau processus. La fonction \textbf{clone()} a le même effet que \textbf{fork()}, sauf qu'il permet, si l'on le souhaite, de choisir si le processus enfant partage l'espace d'adressage du parent ou non.
\\Contrairement à \textbf{fork()}, cet appel système fournit un contrôle plus précis sur les éléments de contexte d'exécution. Il est partagé entre le processus appelant et le processus enfant.
\\\\Quand le processus fils est créé, avec clone(), il exécute la fonction fn(arg) de l'application. (Ceci est différent de fork(2) avec lequel l'exécution continue dans le fils au point de l'appel fork(2)) L'argument 'arg' de fn est un pointeur sur la fonction appelée par le processus fils lors de son démarrage. 'arg' est transmis à la fonction fn lors de son invocation.
\\\\A PARLER DANS POWERPOINT
\\\\Quand la fonction fn(arg) retourne, le processus fils se termine. La valeur entière renvoyée par fn est utilisée comme code de retour du processus fils. Ce dernier peut également se terminer de manière explicite en appelant la fonction exit(2) ou après la réception d'un signal fatal.
\\\\A PARLER DANS POWERPOINT
\\\\L'argument *stack indique l'emplacement de la pile utilisée par le processus fils. Comme les processus fils et appelant peuvent partager de la mémoire, il n'est généralement pas possible pour le fils d'utiliser la même pile que son père. Le processus appelant doit donc préparer un espace mémoire pour stocker la pile de son fils, et transmettre à clone() un pointeur sur cet emplacement. Les piles croissent vers le bas sur tous les processeurs implémentant Linux (sauf le HP PA), donc *stack doit pointer sur la plus haute adresse de l'espace mémoire prévu pour la pile du processus fils.
\\\\L'octet de poids faible de flags contient le numéro du signal de terminaison qui sera envoyé au père lorsque le processus fils se terminera. Si ce signal est différent de SIGCHLD, le processus parent doit également spécifier les options \_\_WALL ou \_\_WCLONE lorsqu'il attend la fin du fils avec wait(2). Si aucun signal n'est indiqué, le processus parent ne sera pas notifié de la terminaison du fils. 
\\\\Les \textit{flags} permet également de préciser ce qui sera partagé entre le père et le fils, en effectuant un OU binaire entre zéro ou plusieurs des constantes suivantes: \url{http://manpagesfr.free.fr/man/man2/clone.2.html}

\newpage
\subsection{Déclaration de clone(2)}
\begin{lstlisting}
#define _GNU_SOURCE
#include <sched.h>

int clone(int (*fn)(void *), void *stack, int flags, void *arg, ...
/* pid_t *parent_tid, void *tls, pid_t *child_tid */ );
\end{lstlisting}

\subsection{Historique}
Peut-être que Linux aurait dû avoir un appel système de création de threads - Linux aurait alors pu s'épargner la douleur de la première implémentation de pthread pour Linux. (Beaucoup d'erreurs ont été commises sur le chemin du NPTL.) Linux aurait dû apprendre de Solaris/SVR4, où l'émulation des sockets BSD via libsocket au-dessus de STREAMS s'est avérée être une erreur qui a pris beaucoup de temps et beaucoup d'argent à corriger . L'émulation d'une API à partir d'une autre API avec des décalages d'impédance est généralement au mieux difficile.
\\\\Depuis lors, clone(2) est devenu un couteau suisse - il a évolué pour avoir des fonctionnalités d'entrée dans les zones/prison, mais seulement en quelque sorte : Linux n'a pas de zones appropriées, à la place, Linux a ajouté de nouveaux drapeaux à clone(2) pour indiquer ce qui ne doit pas être partagé avec le parent. Et au fur et à mesure que de nouveaux drapeaux de clone(2) liés au conteneur furent ajoutés, les anciens codes ayant utilisé clone(2) pouvait souhaiter les avoir utilisés... il faudra modifier et reconstruire le monde appelant clone(2).


\subsection{Fonctionnement}
A PARLER DANS LE POWERPOINT
Quand le processus enfant est créé par  la  fonction clone(), il  débute  son exécution  par un appel à la fonction vers laquelle pointe l'argument fn (cela est différent de fork(2), pour lequel l'exécution continue dans le processus enfant à partir du moment de l'appel de fork(2)). L'argument 'arg' est passé comme argument de la fonction fn.
\\\\Quand la fonction fn(arg) renvoie, le processus  enfant  se  termine. La  valeur  entière renvoyée  par  fn  est  utilisée comme code de retour du processus enfant. Ce dernier peut également se terminer de manière explicite en invoquant la fonction exit(2)  ou  après  la réception d'un signal fatal.
\\\\L'argument  stack indique l'emplacement de la pile utilisée par le processus enfant. Comme les processus enfant et appelant peuvent partager de la mémoire, il n'est généralement pas possible  pour l'enfant d'utiliser la même pile que son parent. Le processus appelant doit donc préparer un espace mémoire pour stocker la pile de son enfant, et transmettre à clone un  pointeur sur cet emplacement. Les piles croissent vers le bas sur tous les processeurs implémentant Linux (sauf le HP PA), donc stack doit pointer sur la plus haute  adresse  de l'espace  mémoire prévu pour la pile du processus enfant. Pourtant, clone() ne fournit aucun moyen pour que l'appelant puisse informer le noyau de la taille de  la  zone  de  la pile.

\subsection{particularités}
L'appel  système  clone3()  fournit  un  sur-ensemble  de  la fonctionnalité de l'ancienne interface de clone(). Il offre également un certain nombre d'améliorations de l'API dont : un  espace  pour  des  bits d'attributs  supplémentaires, une séparation plus propre dans l'utilisation de plusieurs paramètres et la possibilité d'indiquer la taille de la zone de la pile de l'enfant.
\\\\Comme  avec fork(2), clone3() renvoie à la fois au parent et à l'enfant. Il renvoie 0 dans le processus enfant et il renvoie le PID de l'enfant dans le parent.
\\\\Le paramètre cl\_args de clone3() est une structure ayant la forme suivante :

\begin{lstlisting}

\\\\A NE PAS PARLER DANS LE POWERPOINT
struct clone_args {
               u64 flags;        /* Masque de bit d'attribut */
               u64 pidfd;        /* Où stocker le descripteur de fichier du PID
                                    (pid_t *) */
               u64 child_tid;    /* Où stocker le TID enfant,
                                    dans la mémoire de l'enfant's memory (pid_t *) */
               u64 parent_tid;   /* Où stocker le TID enfant,
                                    dans la mémoire du parent's memory (int *) */
               u64 exit_signal;  /* Signal à envoyer au parent quand
                                    l'efant se termine */
               u64 stack;        /* Pointeur vers l'octet le plus faible de la pile */
               u64 stack_size;   /* Taille de la pile */
               u64 tls;          /* Emplacement du nouveau TLS */
               u64 set_tid;      /* Pointeur vers un tableau pid_t
                                    (depuis Linux 5.5) */
               u64 set_tid_size; /* Nombre d'éléments dans set_tid
                                    (depuis Linux 5.5) */
               u64 cgroup;       /* Descripteur de fichier du cgroup cible
                                    de l'enfant (depuis Linux 5.7) */
           };
\end{lstlisting}
Le paramètre size fourni à clone3() doit être initialisé à la taille de  cette  structure (l'existence   du   paramètre  size  autorise  des  extensions  futures  de  la  structure clone\_args).
\\\\La pile du processus enfant est indiquée avec cl\_args.stack, qui pointe  vers  l'octet  le plus faible de la zone de la pile, et avec cl\_args.stack\_size, qui indique la taille de la pile en octets. Si l'attribut CLONE\_VM est indiqué, une pile  doit  être explicitement allouée et indiquée. Sinon, ces deux champs peuvent valoir NULL et 0, ce qui amène l'enfant à utiliser la même zone de pile que son parent (dans  l'espace  d'adressage virtuel de son propre enfant).

\begin{large}
    Équivalence entre les paramètres de clone() et de clone3()
\end{large}
\begin{table}[ht]
\caption{clone() vs clone3()} % title of Table
\centering % used for centering table
\begin{tabular}{c c c } % centered columns (4 columns)
\hline\hline %inserts double horizontal lines
clone() & clone3() & Notes \\ [0.5ex] % inserts table
%heading
\hline % inserts single horizontal line
--- & Champ cl\_args &  \\ % inserting body of the table
attributs \& ~0xff & attributs & Pour la plupart des attributs ; détails ci-dessous \\
parent\_tid & pidfd & Voir CLONE\_PIDFD \\
child\_tid & child\_tid & Voir CLONE\_CHILD\_SETTID \\
parent\_tid & parent\_tid & Voir CLONE\_PARENT\_SETTID \\
child\_tid & child\_tid & Voir CLONE\_CHILD\_SETTID \\
attributs \& 0xff & exit\_signal \\
pile & pile \\
--- & stack\_size \\
tls & tls & Voir CLONE\_SETTLS \\
--- & set\_tid \\
--- & set\_tid\_size \\
--- & cgroup & Voir CLONE\_INTO\_CGROUP \\ [1ex] % [1ex] adds vertical space
\hline %inserts single line
\end{tabular}
\label{table:nonlin} % is used to refer this table in the text
\end{table}
\\\\\\Signal de fin de l'enfant
\\Quand  le  processus enfant se termine, un signal peut être envoyé au parent. Le signal de fin  est  indiqué  dans  l'octet  de   poids   faible de   flags (clone())   ou   dans cl\_args.exit\_signal (clone3()). Si ce signal est différent de SIGCHLD, le processus parent doit également spécifier les options  \_\_WALL  ou  \_\_WCLONE lorsqu'il  attend  la  fin  de l'enfant  avec  wait(2). Si aucun signal n'est indiqué (donc zéro), le processus parent ne sera pas notifié de la terminaison de l'enfant.

A PARLER DANS LE POWERPOINT
\subsection{Problèmes éventuels}
Les versions de la bibliothèque C GNU jusqu'à la 2.24 comprise  contenaient  une  fonction enveloppe  pour  getpid(2) qui effectuait un cache des PID. Ce cache nécessitait une prise en charge par l'enveloppe de clone() de la glibc, mais des limites  dans  l'implémentation faisaient  que  le  cache  pouvait  ne  pas  être  à jour sous certaines circonstances. En particulier, si un signal était distribué à un enfant juste après l'appel à clone(), alors un  appel à getpid(2) dans le gestionnaire de signaux du signal pouvait renvoyer le PID du processus appelant (le parent), si l'enveloppe de clone n'avait toujours pas eu  le temps de  mettre le cache de PID à jour pour l'enfant. (Ce point ignore le cas où l'enfant a été créé en utilisant CLONE\_THREAD, quand getpid(2) doit renvoyer la même valeur pour l'enfant et pour le processus qui a appelé clone(), puisque l'appelant et l'enfant se trouvent dans le même groupe de threads. Ce problème de cache n'apparaît pas non plus  si  le  paramètre flags  contient  CLONE\_VM.)  Pour  obtenir  la  véritable  valeur, il peut être nécessaire d'utiliser quelque chose comme ceci :
\begin{lstlisting}
           #include <syscall.h>

           pid_t mypid;

           mypid = syscall(SYS_getpid);
\end{lstlisting}
\textit{Donc, suite à un problème ancien de cache, ainsi qu'à d'autres problèmes traités dans getpid(2), la fonctionnalité de mise en cache du PID a été supprimée de la glibc 2.25.}
\subsection{Code}

\begin{lstlisting}
// Il est nécessaire de définir _GNU_SOURCE pour avoir acces à clone(2) et aux flags CLONE_*

#define _GNU_SOURCE
#include <sched.h>
#include <sys/syscall.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

static int child_func(void* arg) {
    char* buffer = (char*)arg;
    printf("Child sees buffer = \"%s\"\n", buffer);
    strcpy(buffer, "Hello from child");
    return 0;
}

/**
 Ici, clone() est utilisé de deux manières : une fois avec le flag CLONE_VM (CLONE_VM = clone virtual memory) et une fois sans.
 Un buffer est passé dans le processus enfant, et le processus enfant y écrit un string.
 Une pile de taille 65536 ensuite allouée pour le processus enfant et une fonction qui vérifie si nous exécutons le fichier en utilisant l'option 'vm' (correspondant donc au flag 'CLONE_VM').
 De plus, un buffer de 100 octets est créé dans le processus parent et une chaîne y est copiée, puis, l'appel système clone() est exécuté et les erreurs sont vérifiées.

 Lorsque d'une exécution sans l'argument 'vm' se produit, le flag CLONE_VM n'est pas actif et la mémoire virtuelle du processus parent est clonée dans le processus enfant.
 Le processus enfant peut accéder au message passé par le processus parent dans le buffer, mais tout ce qui est écrit dans le buffer par l'enfant n'est pas accessible par processus parent puisque la mémoire virtuelle est dupliquée pour être allouée au processus enfant.
 */
int main(int argc, char** argv) {
    // Alloue un stack pour la tâche du fils
    const int STACK_SIZE = 65536;
    char* stack = malloc(STACK_SIZE);
    if (!stack) { // Si 'stack' n'a pas été correctement créé
        perror("malloc");
        exit(1);
    }

    // Lorsqu'il est appelé avec l'argument 'vm' en ligne de commande, active le flag CLONE_VM.
    unsigned long flags = 0;
    if (argc > 1 && !strcmp(argv[1], "vm")) {

        /**
         int clone(int (*fn)(void *), void *child_stack,
                   int flags, void *arg, ...
                   pid_t *ptid, struct user_desc *tls, pid_t *ctid );
         */

        /**
         Lorsque le processus enfant est créé avec clone(), il exécute la fonction fn(arg).
         (Cela diffère de fork(2) dans lequel l'exécution continue dans le fils à partir du point d'appel de fork(2).)
         L'argument fn est un pointeur vers une fonction qui est appelée par le processus fils au début de son exécution. L'argument 'arg' est passé à la fonction fn.
         */
        /**
         CLONE_VM (depuis Linux 2.0)
                      Si CLONE_VM est défini, le parent et l'enfant seront exécuté dans le même espace mémoire. En particulier les écritures mémoire effectuées par le parent ou par l'enfant sont également visibles dans l'autre processus.
                      De plus, tout mappage ou démappage de mémoire effectué avec mmap(2) ou munmap(2) par le processus enfant ou appelant également affecte l'autre processus.

                      Si CLONE_VM n'est pas défini, le processus enfant s'exécute dans un copie séparée de l'espace mémoire du processus appelant au moment de l'appel de clone. Les écritures effectuées par les mappages/démappages par un des processus n'affecte pas l'autre, comme avec fork(2).
         */
        flags |= CLONE_VM; // 'flags' vaudra 'CLONE_VM' ou non en fonction du fait que l'option 'vm' soit spécifiée ou non.
    }

    char buffer[100];
    strcpy(buffer, "Hello from parent"); // Ecrit 'hello from parent' dans le buffer
    // Clone le processus père
    // Seul appel à 'clone'. Pour avoir les différentes exécutions, il faut ajouter 'vm' comme argument lors de l'appel en ligne de commande
    // Vu que lorsque CLONE_VM est défini, l'espace d'adressage mémoiire est partaé,
    // le buffer est le même pour le père et pour le fils, donc, le fils override ce que le père a écrit par 'hello from child'
    if (clone(child_func, stack + STACK_SIZE, flags | SIGCHLD, buffer) == -1) {
        perror("clone");
        exit(1);
    }

    int status;
    if (wait(&status) == -1) {
        perror("wait");
        exit(1);
    }

    printf("Child exited with status %d. buffer = \"%s\"\n", status, buffer);
    return 0;
}

\end{lstlisting}

\subsection{Résultats}
\subsubsection{./clone}
\begin{lstlisting}
Child sees buffer = "Hello from parent"
Child exited with status 0. buffer = "Hello from parent"
\end{lstlisting}

\subsubsection{./clone vm}
\begin{lstlisting}
Child sees buffer = "Hello from parent"
Child exited with status 0. buffer = "Hello from child"
\end{lstlisting}








%----------------------------------------------------------------------------------------
%	Aller plus loin
%----------------------------------------------------------------------------------------

\section{Aller plus loin}
L'ajout de la fonction forkall() au standard a été considéré et rejeté. La fonction forkall() permet à tous les threads du parent d'être dupliqués dans l'enfant. Ceci reproduit essentiellement l'état du parent chez l'enfant. Cela permet aux threads de l'enfant de poursuivre le traitement et permet de préserver les verrous et l'état sans code pthread\_atfork() explicite.
\\Le processus appelant doit s'assurer que l'état de traitement des threads qui est partagé entre le parent et l'enfant (c'est-à-dire les descripteurs de fichiers ou la mémoire MAP\_SHARED) se comporte correctement après forkall(). Par exemple, si un thread lit un descripteur de fichier dans le parent lorsque forkall() est appelée, alors deux threads (un dans le parent et un dans le child) lisent le fichier filedescriptor après la forkall(). Si ce n'est pas un comportement souhaité, le processus parent doit se synchroniser avec de tels threads avant d'appeler forkall().

Les fonctions forkx() et forkallx() acceptent un argument flags constitué d'un OU inclusif bit à bit de zéro ou plus des drapeaux suivants, qui sont définis dans l'en-tête sys/fork.h
Si l’argument des flags est à 0, alors forkx() aura le même comportement que fork() et forkallx() aura le même comportement que forkall().






%----------------------------------------------------------------------------------------
%	Conclusion
%----------------------------------------------------------------------------------------

\section{Conclusion}
A PARLER DANS LE POWERPOINT
Pour finir, nous pouvons constater que fork() et vfork() sont des fonctions et appels système qui existent depuis longtemps. clone() a pris le relais de par sa puissance et sa modularité.
\\Donc, pour tout programme un minimum lourd, il est meilleur d'implémenter vfork() ou clone() avec les flags nécessaires afin d'utiliser la mémoire virtuelle de manière pertinente et efficace.




%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\section{Sources}
\begin{sloppypar}
\url{https://man7.org/linux/man-pages/man2/clone.2.html}\\
\url{https://cpp.hotexamples.com/fr/examples/-/-/vfork/cpp-vfork-function-examples.html}\\
\url{https://man7.org/linux/man-pages/man2/vfork.2.html}\\
\url{https://www.ibm.com/docs/en/SSLTBW_2.4.0/com.ibm.zos.v2r4.bpxbd00/rvfork.html}\\
\url{https://mindsgrid.com/difference-fork-vfork-exec-clone/}\\
\url{https://stackoverflow.com/questions/4856255/the-difference-between-fork-vfork-exec-and-clone}\\
\url{https://prograide.com/pregunta/11064/la-difference-entre-fork-vfork-exec-et-clonee}\\
\url{http://www.unixguide.net/unix/programming/1.1.2.shtml}\\
\url{https://prograide.com/pregunta/12758/differences-entre-exec-et-fourche}\\
\url{https://man7.org/linux/man-pages/man2/fork.2.html}\\
\url{https://techdifferences.com/difference-between-fork-and-vfork.html}\\
\url{https://www.ibm.com/docs/en/zos/2.4.0?topic=functions-vfork-create-new-process}\\
\url{https://man7.org/linux/man-pages/man2/fork.2.html}\\
\url{https://www.linuxjournal.com/article/5211}\\
\url{https://man7.org/linux/man-pages/man2/clone.2.html}\\
\url{http://www-igm.univ-mlv.fr/~dr/CS/node88.html}\\
\url{https://gist.github.com/nicowilliams/a8a07b0fc75df05f684c23c18d7db234}\\
\url{https://fresh2refresh.com/c-programming/c-buffer-manipulation-function/}\\
\url{https://stackoverflow.com/questions/66548922/can-a-fork-child-determine-whether-it-is-a-fork-or-a-vfork}\\
\url{https://news.ycombinator.com/item?id=30502392}\\
\url{https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/vfork.2.html}\\
\url{http://manpagesfr.free.fr/man/man2/clone.2.html}\\
\url{https://gist.github.com/alifarazz/d1ccf716131ed3a369fc7d248d910330}\\
\url{https://linux.die.net/man/2/clone}\\
\url{https://www.thegeekstuff.com/2012/05/c-mutex-examples/}\\
\url{https://docs.oracle.com/cd/E26502_01/html/E35303/gen-1.html}\\
\url{https://mindsgrid.com/difference-fork-vfork-exec-clone/}\\
\url{https://stackoverflow.com/questions/21205723/how-many-ways-we-can-create-a-process-in-linux-using-c}\\
\url{https://cpp.hotexamples.com/fr/examples/-/-/vfork/cpp-vfork-function-examples.html}\\
\url{https://man7.org/linux/man-pages/man2/vfork.2.html}\\
\url{https://www.ibm.com/docs/en/zos/2.4.0?topic=functions-vfork-create-new-process}\\
\url{https://mindsgrid.com/difference-fork-vfork-exec-clone/}\\
\url{https://stackoverflow.com/questions/4856255/the-difference-between-fork-vfork-exec-and-clone}\\
\url{https://prograide.com/pregunta/11064/la-difference-entre-fork-vfork-exec-et-clone}\\
\url{http://www.unixguide.net/unix/programming/1.1.2.shtml}\\
\url{https://prograide.com/pregunta/12758/differences-entre-exec-et-fourche}\\
\url{https://techdifferences.com/difference-between-fork-and-vfork.html}\\
\url{https://manpages.ubuntu.com/manpages/hirsute/fr/man2/clone.2.html}\\
\url{http://manpagesfr.free.fr/man/man2/clone.2.html}\\
\url{https://github.com/jeremyong/google-coredumper/issues/14}\\
\url{https://stackoverflow.com/questions/29264322/mmap-error-on-linux-using-somethingelse}\\
\url{https://man7.org/linux/man-pages/man7/signal.7.html}\\
\url{https://stackoverflow.com/questions/9361816/maximum-number-of-processes-in-linux}\\
\url{https://www.2daygeek.com/kill-terminate-a-process-in-linux-using-kill-pkill-killall-command/}\\
\url{https://www.baeldung.com/linux/fork-vfork-exec-clone}\\
\end{sloppypar}

\end{document}