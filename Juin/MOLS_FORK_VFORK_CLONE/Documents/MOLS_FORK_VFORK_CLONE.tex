%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University/School Laboratory Report
% LaTeX Template
% Version 4.0 (March 21, 2022)
%
% This template originates from:
% https://www.LaTeXTemplates.com
%
% Authors:
% Léopold Mols
% Linux and Unix Users Group at Virginia Tech Wiki
%
% License:
% CC BY-NC-SA 4.0 (https://creativecommons.org/licenses/by-nc-sa/4.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[
    a4paper % Paper size, specify a4paper (A4) or letterpaper (US letter)
	12pt, % Default font size, specify 10pt, 11pt or 12pt
	article,
	utf8,
	latin1
]{CSUniSchoolLabReport}

\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{blindtext}
\addbibresource{sample.bib} % Bibliography file (located in the same folder as the template)

\lstset{
  aboveskip=3mm,
  belowskip=-2mm,
  basicstyle=\footnotesize,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  deletekeywords={...},
  escapeinside={\%*}{*)},
  extendedchars=true,
  framexleftmargin=16pt,
  framextopmargin=3pt,
  framexbottommargin=6pt,
  frame=tb,
  keepspaces=true,
  language=C,
  literate=
  {²}{{\textsuperscript{2}}}1
  {⁴}{{\textsuperscript{4}}}1
  {⁶}{{\textsuperscript{6}}}1
  {⁸}{{\textsuperscript{8}}}1
  {€}{{\euro{}}}1
  {é}{{\'e}}1
  {è}{{\`{e}}}1
  {ê}{{\^{e}}}1
  {ë}{{\¨{e}}}1
  {É}{{\'{E}}}1
  {Ê}{{\^{E}}}1
  {û}{{\^{u}}}1
  {ù}{{\`{u}}}1
  {â}{{\^{a}}}1
  {à}{{\`{a}}}1
  {á}{{\'{a}}}1
  {ã}{{\~{a}}}1
  {Á}{{\'{A}}}1
  {Â}{{\^{A}}}1
  {Ã}{{\~{A}}}1
  {ç}{{\c{c}}}1
  {Ç}{{\c{C}}}1
  {õ}{{\~{o}}}1
  {ó}{{\'{o}}}1
  {ô}{{\^{o}}}1
  {Õ}{{\~{O}}}1
  {Ó}{{\'{O}}}1
  {Ô}{{\^{O}}}1
  {î}{{\^{i}}}1
  {Î}{{\^{I}}}1
  {í}{{\'{i}}}1
  {Í}{{\~{Í}}}1,
  morekeywords={*,...},
  numbers=left,
  numbersep=10pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stepnumber=1,
  tabsize=4,
  title=\lstname,
}

%----------------------------------------------------------------------------------------
%	Début du rapport
%----------------------------------------------------------------------------------------

\title{fork() \\ vfork() \\ clone()} % Report title

\author{Léopold \textsc{Mols}} % Author name(s), add additional authors like: '\& James \textsc{Smith}'

\date{\today}

\begin{document}

\maketitle % Insert the title, author and date using the information specified above

\begin{center}
	\begin{tabular}{l r}
		Année: & SYSG6 Q2 2021-2022 \\ % Date the experiment was performed
		Professeur: & Mme \textsc{Bastreghi} % Professeur/supervisor
	\end{tabular}
\end{center}

\tableofcontents

\section{Que sont-ils ?}
fork() (cfr \ref{definitionFORK} : \textit{fork()}), vfork() (cfr \ref{definitionVFORK} : \textit{vfork()}), clone() (cfr \ref{definitionCLONE} : \textit{clone()}) permettent de créer des processus s'exécutant.
\\\\
Au démarrage d'un système Unix, un seul processus existe (numéro 1). Tous les autres processus qui peuvent exister au cours de la vie du système descendent de ce premier processus, appelé init, via des appels système comme fork, vfork, forkx(), forkall(), forkallx(), vforkx() ou d'autres moyens sont des appels système standard d'UNIX (norme POSIX) permettant de créer des processus.


%-------------------------------------------------------------------------
%	FORK()
%-------------------------------------------------------------------------

\section{
    \begin{LARGE}
        fork()
    \end{LARGE}
}\label{fork()}

\subsection{Qu'est-ce}\label{definitionFORK}
\textbf{fork()} crée un nouveau processus en dupliquant le processus appelant.\\
\\Le nouveau processus est appelé \textit{processus enfant}. L'appel processus est appelé \textit{processus parent}. Le \textit{processus enfant} et le \textit{processus parent} s'exécutent dans une \underline{mémoire} \underline{séparée}. Au moment de \textbf{fork()}, les deux \textit{espaces mémoire} ont le \underline{même contenu}. \\Écritures en mémoire, mappages de fichiers (mmap()) et démappages (munmap()) exécutés par l'un des processus n'affecte pas l'autre.

\subsection{Déclaration de fork(2)}
\begin{lstlisting}
#include <unistd.h>

pid_t fork(void);
\end{lstlisting}

\subsection{Historique}
Sur les premiers UNIX (1969 $\rightarrow$ années 1990), seul l'appel système fork permet de créer de nouveaux processus.
La fonction fork fait partie des appels système standard d'UNIX (norme POSIX (Portable Operating System Interface et le X exprime l'héritage UNIX) qui est une famille de normes techniques définie depuis 1988 par l'Institute of Electrical and Electronics Engineers (IEEE), et formellement désignée par IEEE 1003. Ces normes ont émergé d'un projet de standardisation des interfaces de programmation des logiciels destinés à fonctionner sur les variantes du système d'exploitation UNIX).

\subsection{Fonctionnement}
L'appel système fork fournit une valeur résultat qui est entière. Pour différencier le père du fils, il suffit de regarder la valeur de retour du fork() qui peut être :
\begin{itemize}
  \item le PID du fils, auquel cas nous sommes dans le processus père
  \item 0 auquel cas nous sommes dans le processus fils.
  \item -1 qui témoigne une erreur lors de l’exécution de la commande, aucun processus enfant n'est créé et errno est modifié pour indiquer l'erreur.
\end{itemize}

Il est possible d’interagir entre processus de plusieurs manières différentes. Premièrement, on peut envoyer des signaux. En langage de commande kill <pid> permet de tuer le processus ayant pour pid ce que l'on entre dans la commande.
Il est possible de faire attendre un processus grâce à sleep(n) pour bloquer le processus pendant n secondes, ou en utilisant pause() qui bloque jusqu'à la réception d'un signal.
Pour mettre fin à un processus, on peut utiliser exit(state) sachant que state est un code de fin, par convention 0 si ok, code d'erreur sinon.
Il peut être très pratique que le père attende la fin de l'un de ses fils, pour ce faire on utilise pid\_t wait(int *ptr\_state) qui donne comme valeur de retour le pid du fils qui a terminé, et le code de fin est stocké dans ptr\_state.
On peut également attendre la fin du fils grâce à son pid : pid\_t waitpid(pid\_t pid, int *ptr\_state, int options).
Un terme commun dans la partie « Système » de l'informatique est ce que l'on appelle les processus zombies. Cela arrive quand le processus est terminé mais que le père n'a pas attendu son fils, c'est-à-dire qu'il n'a pas fait d'appels à wait(). C'est une situation qu'il convient d'éviter absolument car le processus ne peut plus s'exécuter mais consomme encore des ressources. 

\subsection{particularités}
\begin{itemize}
    \item
        \begin{description}
            \item[L'espace d'adressage] est dupliqué
            \item[Le processus enfant] est une copie exacte du processus parent sauf pour
        \end{description}
    \item
        \begin{itemize}
            \item[$\ast$] L'enfant a son propre ID de processus unique, et ce PID est unique
            \item[$\ast$] L'enfant n'hérite pas des verrous de mémoire de son parent
            \item[$\ast$] La table des signaux est remise à 0 pour     l'enfant
            \item[$\ast$] L'enfant n'hérite pas des sémaphores de son parent
            \item[$\ast$] L'enfant n'hérite pas des verrous d'enregistrement associés au processus parent
            \item[$\ast$] L'enfant n'hérite pas des minuteries de son parent 
            \item[$\ast$] L'enfant n'hérite pas des E/S asynchrones en suspens ni des contextes d'E/S asynchrones de son parent
        \end{itemize}
\end{itemize}

\subsection{Problèmes éventuels}
Au vu du fait que fork duplique l'espace d'adressage et d'autres fonctionnement du parent (comme les threads,...), cela peut vite remplir la mémoire, ralentir l'ordinateur et empêcher la création de nouveaux processus.
\\\\fork() a donné aux créateurs d'Unix la possibilité de déplacer toute cette complexité du kernel-land vers le user-land, où il est beaucoup plus facile de développer des logiciels. Cela les a rendus plus productifs, peut-être beaucoup plus. Le prix que les créateurs d'Unix ont payé pour cette élégance était la nécessité de copier les espaces d'adressage. Étant donné qu'à l'époque, les programmes et les processus étaient petits, l'inélégance était facile à négliger ou à ignorer. Mais maintenant, les processus ont tendance à être énormes et multithreads, ce qui rend extrêmement coûteux la copie même de l'ensemble résident d'un parent et la manipulation de la table des pages pour le reste.

\subsection{Suppléments}
fork1(), forkall(), forkx(), forkallx()
Les fonctions forkx() et forkallx() acceptent un argument flags composé d'un OU inclusif au niveau du bit de zéro ou plusieurs des drapeaux suivants, qui sont définis dans l'en-tête sys/fork.h
Si l'argument flags est 0, forkx() est identique à fork() et forkallx() est identique à forkall().

\subsection{Code}
\begin{normalsize}
Ce code effectue une addition de 2 variables par le fils pour prouver que les variables du père sont modifiées par le fils puisque le père et le fils partagent le même espace d'adressage.
\end{normalsize}

\begin{lstlisting}
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <mm_malloc.h>
#include <spawn.h>

int main(int argc, char **argv) {

    int a = 5, b = 8;
    int v;

    /**
    * Le FORK duplique l'espace d'adressage.
    * 
    * Donc, le FORK fera les additions de son côté.
    *  Ensuite, le fils sera exit, donc,
    *  il n'affichera pas le résultat de ses additions
    *
    * Du côté du père, l'addition ne sera pas faite puisqu'il exécutera
    * seulement le code suivant le "if"
    *
    * Vu que l'espace d'adressage est dupliqué lors du FORK, les
    * variables ne seront modifiées que dans
    * l'espace d'adressage du FILS.
    *  Donc, les variables du père ne sont pas modifiées
    */
    v = fork();
    if(v == 0) {
        // 10
        a = a + 5;
        // 10
        b = b + 2;
        exit(0);
    }
    // Parent code
    wait(0);
    printf("PID = %d\n", getpid());
    printf("PPID = %d\n", getppid());
    printf("Value of v is %d.\n", v); // line a
    printf("Sum is %d.\n", a + b); // line b
    sleep(4000);
    printf("Let's do a ps to see which process is currenlty running !");
    exit(0);
}

/*int main()
{
    int a = 10, errFils;
    printf ("Before Forking\n");
    printf ("%d\n", a);
    if ((errFils = fork()) == 0)
    {
        a = 20;
        /**
        * exit(0); // Remplacer par "wait(0)" pour montrer la différence
        * pour démontrer que seul le fils exécutera la suite puisque c'est
        * le même espace d'adressage, donc, la même TDFO, donc, une fois
        * que la variable sera changée et que le fils se sera occupé de
        * print sur la sortie standard, le père n'aura pus à le faire car * stdout ne sera plus dans la TDFO.
        */
        
        /**
        * wait est un processus bloquant. Donc, la suite ne sera pas
        * exécutée tant qu'une condition ne sera pas remplie. Si l'on met
        * un pointeur d'un nombre, alors, on pourra récupérer le code de
        * terminaison du processus enfant. Pareil pour exit
        */
        
        /**
        * Attention : le "exit(0)" le tue, mais ne l'enlève pas de la
        * table des process et envoie un signal à son parent
        */
    }
    wait(errFils);
    printf ("After Forking\n");
    printf ("%d\n", a);
}*/
\end{lstlisting}
\subsection{Resultat}
\begin{lstlisting}
a = 5
b = 8
Ceci est le process parent et le PID est : 31151
I'm the child !
Now, a = 10 only in the child
Now, b = 10 only in the child
PID = 31152
PPID = 31151
Sum a + b is 20.
Let's do a ps to see which process is currenlty running !

CODES D'ÉTAT DE PROCESSUS 
Voici les différentes valeurs que les indicateurs de sortie s, stat et state (en-tête « STAT » ou « S ») afficheront pour décrire l'état d'un processus :

D    en sommeil non interruptible (normalement entrées et sorties) ;
R    s'exécutant ou pouvant s'exécuter (dans la file d'exécution) ;
S    en sommeil interruptible (en attente d'un événement pour finir) ;
T    arrêté, par un signal de contrôle des tâches ou parce qu'il a été tracé ;
W    pagination (non valable depuis le noyau 2.6.xx) ;
X    tué (ne devrait jamais être vu) ;
Z    processus zombie (<defunct>), terminé mais pas détruit par son parent.

Pour les formats BSD et quand le mot-clé stat est utilisé, les caractères supplémentaires suivants peuvent être affichés :

<    haute priorité (non poli pour les autres utilisateurs) ;
N    basse priorité (poli pour les autres utilisateurs) ;
L    avec ses pages verrouillées en mémoire (pour temps réel et entrées et sorties personnalisées) ;
s    meneur de session ;
l    possède plusieurs processus légers (« multi-thread », utilisant CLONE\_THREAD comme NPTL pthreads le fait) ;
+    dans le groupe de processus au premier plan.

PID = 31151
PPID = 28756
Value of f is 31152.
Sum is 13.
Terminated
\end{lstlisting}

 
 
 
 
 
%-------------------------------------------------------------------------
%	VFORK()
%-------------------------------------------------------------------------
\newpage
\section{
    \begin{LARGE}
        vfork()
    \end{LARGE}
}\label{vfork()}

\subsection{Qu'est-ce}\label{definitionVFORK}
\textbf{vfork()} crée un nouveau processus. La fonction \textbf{vfork()} a le même effet que \textbf{fork()}, sauf que le comportement n'est pas défini, si le processus créé par vfork() tente d'appeler toute autre fonction C/370 avant d'appeler exec() ou \_exit().

\subsection{Déclaration de vfork(2)}
\begin{lstlisting}
#include <sys/types.h> 
#include <unistd.h>

pid_t vfork(void);
\end{lstlisting}

\subsection{Historique}
L'appel système vfork() est apparu dans BSD 3.0. Dans BSD 4.4, il est devenu synonyme de fork(), mais NetBSD l'a réintroduit à nouveau : voir \\\url{http://www.netbsd.org/Documentation/kernel/vfork.html}.\\\\Sous Linux, il fut l'équivalent de fork() jusqu'au noyau 2.2.0-pre-6. Depuis le 2.2.0-pre-9 il s'agit d'un appel système indépendant. Le support dans la bibliothèque a été introduit dans la glibc 2.0.112.
\subsection{Fonctionnement}
L’espace d’adressage n’est pas un nouveau par rapport au père lors de la duplication comme pour un fork(), mais l’espace d’adressage sera le même. Cela peut permettre de faire en sorte que, si le processus fils se passe correctement, le père n’aura plus rien à faire, plutôt que de d’office reprendre la main après le fils.
\\\\vfork(), tout comme fork(), crée un processus fils à partir du processus appelant. Pour plus de détails sur les valeurs renvoyées et les erreurs possibles, voir fork().
vfork() est conçu comme un cas particulier de clone(). Il sert à créer un nouveau processus sans effectuer de copie de la table des pages mémoire du processus père. Ceci peut être utile dans des applications nécessitant une grande rapidité d'exécution, si le fils doit invoquer immédiatement un appel execve().
\\\\vfork() diffère aussi de fork() car le processus père reste suspendu jusqu'à ce que le fils invoque execve(), ou \_exit(). Le fils partage toute la mémoire avec son père, y compris la pile, jusqu'à ce que execve() soit appelé par le fils. Le processus fils ne doit donc pas revenir de la fonction en cours, ni invoquer une nouvelle routine. Il ne doit pas appeler exit(3), mais à la place \_exit().
\\\\Les gestionnaires de signaux sont hérités mais pas partagés. Les signaux pour le processus père sont délivrés après que le fils ait mis à jour la mémoire du père.  
\\\\Sous Linux, fork() est implémenté en utilisant un mécanisme de copie en écriture, ainsi ses seuls coûts sont le temps et la mémoire nécessaire pour dupliquer la table des pages mémoire du processus père, et créer une structure de tâche pour le fils. Toutefois, jadis fork() nécessitait malheureusement une copie complète de l'espace d'adresse du père, souvent inutile car un appel exec(3) est souvent réalisé immédiatement par le fils. Pour améliorer les performances, BSD a introduit un appel système vfork() qui ne copie pas l'espace d'adressage du père, mais emprunte au père son espace d'adressage et son fil de contrôle jusqu'à un appel à execve() ou exit. Le processus père était suspendu tant que le fils utilisait les ressources. L'utilisation de vfork() était loin d'être facile, car pour éviter de modifier les données du processus père, il fallait être capable de déterminer quelles variables se trouvaient dans des registres du processeur.  
\\\\Donc semblable à l'appel système fork(), vfork() crée également un processus enfant identique à son processus parent. Cependant, le processus enfant suspend temporairement le processus parent jusqu'à ce qu'il se termine. En effet, les deux processus utilisent le même espace d'adressage, qui contient la pile, le pointeur de pile et le pointeur d'instruction.


\subsection{particularités}
\begin{itemize}
    \item
        \begin{description}
            \item[L'espace d'adressage] est dupliqué
            \item[Le processus enfant] est un duplicata exact du processus qui appelle vfork() (le processus parent), à l'exception de ce qui suit :
        \end{description}
    \item
        \begin{itemize}
            \item[$\ast$] Le processus enfant a un ID de processus (PID) unique, qui ne correspond à aucun ID de groupe de processus actif.
            \item[$\ast$] L'enfant a sa propre copie de la TDFO du parent. Chaque descripteur de fichier dans l'enfant fait référence au même descripteur de fichiers ouverts que le descripteur de fichier correspondant dans le parent.
            \item[$\ast$] L'enfant a sa propre copie des flux de répertoires ouverts du parent. Le flux de répertoires ouverts de chaque enfant peut partager le positionnement du flux de répertoires avec le flux de répertoires du parent correspondant.
            \item[$\ast$] L'enfant n'hérite d'aucun verrou de fichier précédemment défini par le parent.
            \item[$\ast$] Le processus enfant n'a pas d'alarmes définies (semblable aux résultats d'un appel à alarm() avec une valeur d'argument de 0).
            \item[$\ast$] L'enfant n'a pas de signaux en attente.
            \item[$\ast$] Les minuteries d'intervalle sont réinitialisées dans le processus enfant.
            \item[$\ast$] Ces éléments sont mis à 0 dans le fils : tms\_utime, tms\_stime, tms\_cutime, tms\_cstime   
        \end{itemize}
\end{itemize}
Toutes les pages de manuel vfork(2) que j'ai vues indiquent que le processus parent est arrêté jusqu'à ce que l'enfant quitte/exécute, mais cela est antérieur aux threads. Linux, par exemple, n'arrête que le seul thread du parent qui a appelé vfork(), pas tous les threads. Je pense que c'est la bonne chose à faire, mais les autres systèmes d'exploitation de l'IIRC arrêtent tous les threads du processus parent (ce qui est une erreur, IMO).

\subsection{Problèmes éventuels}
Il est regrettable que Linux ait ressuscité ce spectre du passé. La page de manuel de BSD indique que cet appel système sera supprimé quand des mécanismes de partage appropriés seront implémentés, et qu'il ne faut pas essayer de tirer profit du partage mémoire induit par vfork(), car dans ce cas, il sera rendu synonyme de fork(2).
\\\\Les détails de la gestion des signaux sont compliqués, et varient suivant les systèmes. La page de manuel BSD indique : « Pour éviter de possibles situations de blocage, les processus qui sont des fils au milieu d'un vfork() ne reçoivent jamais les signaux SIGTTOU ou SIGTTIN ; à la place, des sorties ou des requêtes iotcl sont autorisées et des tentatives d'entrées indiqueront une fin de fichier. »
\\\\ Lors de l'utilisation de vfork(), il arrive souvent que ce message apparaisse lors de la compilation, ce qui montre, par exemple, que l'exécution diffère d'un système à un autre :
\textit{This system call is deprecated. In a future release, it may begin to return errors in all cases, or may be removed entirely.  It is extremely strongly recommended to replace all uses with fork(2) or, ideally, posix\_spawn(3).}
\\\\Mais vfork() a les avantages de fork, et aucun de ses inconvénients !
vfork() a un inconvénient : que le parent (en particulier : le thread dans le parent qui appelle vfork()) et l'enfant partagent une pile, ce qui nécessite que le parent (thread) soit arrêté jusqu'à ce que l'enfant exec() ou \_exit(). (Cela peut être pardonné en raison des longs threads précédents de vfork(2) -- lorsque les threads sont apparus, le besoin d'une pile séparée pour chaque nouveau thread est devenu tout à fait clair et inévitable. La solution pour les threads était d'utiliser une nouvelle pile pour le nouveau thread et utilisez une fonction de rappel et un argument comme principal () pour cette nouvelle pile.) Mais le blocage est mauvais car le comportement synchrone est mauvais, en particulier lorsque vfork (2) (ou clone (2), utilisé comme vfork (2 )) est la seule alternative performante à fork(2), mais cela aurait pu être mieux.


\subsection{Code prouvant l'espace d'adressage partagé}
\begin{normalsize}
Ce code effectue une addition de 2 variables par le fils pour prouver que seules les variables du fils sont modifiées puisque le père et le fils ne partagent pas le même espace d'adressage.
\end{normalsize}

\begin{lstlisting}
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <mm_malloc.h>
#include <spawn.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

/**
 * Le VFORK duplique l'espace d'adressage.
 * Donc, le VFORK fera les additions de son côté, mais dans l'espace d'adressage du PERE
 *  Ensuite, le fils sera exit, donc, il n'affichera pas le résultat de ses additions,
 *  mais les variables sont bien modifiées
 *
 * Du côté du père, l'addition ne sera pas faite puisqu'il partage l'espace d'adressage du FILS
 *
 * Vu que l'espace d'adressage n'est pas dupliqué lors du VFORK, les variables seront modifiées dans
 *  l'espace d'adressage du PERE (qui est aussi celui du fils)
 *  Donc, les variables du père sont modifiées,
 *   ce qui permet la prise en compte de la modification des valeurs des variables faites par le fils
 */
int main(int argc, char **argv) {

    // Entiers à augmenter dans le fils pour prouver l'espace d'adressage commun
    int a = 5, b = 8;
    // Récupérer la valeur de retour de la fonction créant le proocess fils
    int vforkRetNum;

    printf("a = %d\n", a);
    printf("b = %d\n", b);

    vforkRetNum = vfork();

    if(vforkRetNum == 0) { // La création du fils s'est-elle correctement produite ?
        printf("I'm the child !\n");
        // a = 10
        a = a + 5;
        printf("Now, a = %d in the parent as in the child\n", a);

        // b = 10
        b = b + 2;
        printf("Now, b = %d in the parent as in the child\n", b);

        printf("PID = %d\n", getpid());
        printf("PPID = %d\n", getppid());
//        printf("Value of vfork is %d.\n", vforkRetNum); // Indiquer la valeur de retour de la fonciton$        printf("Sum a + b is %d.\n", a + b); // line b
        printf("Let's do a ps to see which process is currenlty running !\n\n");
        printf("CODES D'ÉTAT DE PROCESSUS \nVoici les différentes valeurs que les indicateurs de sortie$

               *D    en sommeil non interruptible (normalement entrées et sorties) ;\n"
               *R    s'exécutant ou pouvant s'exécuter (dans la file d'exécution) ;\n"
               *S    en sommeil interruptible (en attente d'un événement pour finir) ;\n"
               *T    arrêté, par un signal de contrôle des tâches ou parce qu'il a été tracé ;\n"
               *W    pagination (non valable depuis le noyau 2.6.xx) ;\n"
               *X    tué (ne devrait jamais être vu) ;\n"
               *Z    processus zombie (<defunct>), terminé mais pas détruit par son parent.\n\n"

       "Pour les formats BSD et quand le mot-clé stat est utilisé, les caractères supplémentaires suiva$

               *<    haute priorité (non poli pour les autres utilisateurs) ;\n"
               *N    basse priorité (poli pour les autres utilisateurs) ;\n"
               *L    avec ses pages verrouillées en mémoire (pour temps réel et entrées et sorties pers$
               *s    meneur de session ;\n"
               *l    possède plusieurs processus légers (« multi-thread », utilisant CLONE\_THREAD comme$
               *+    dans le groupe de processus au premier plan.\n\n");
        while(1){} // Faire en sorte que le fils attende, mais en étant en état d'exécution. Un simple $
        exit(0);
    }
    else if (vforkRetNum > 0)
    {  // Est-ce le process parent ?
        printf("Ceci est le process parent et le PID est : %d\n", getpid());
    }
    else
    { // Y a-t-il eu une erreur lors de la création du process fils ?
        printf("Problème durant le vfork\n");
        exit(EXIT_FAILURE);
    }
    wait(0); // Pour éviter de faire du fils un zombie
    printf("PID = %d\n", getpid());
    printf("PPID = %d\n", getppid());
    printf("Value of vfork is %d.\n", vforkRetNum); // Indiquer la valeur de retour de la fonction créa$
    // La somme est bien de 20 et non plus ni moins puisque la somme fut faite par le fils avec les mêm$
    printf("Sum a + b is %d.\n", a + b);
    printf("Let's do a ps to see which process is currenlty running !\n");
    while(1){} // Simplement pour faire attendre le père que l'on fasse un ps pour pouvoir voir son état
    exit(0);
}
\end{lstlisting}
\subsection{Résultat}
\begin{lstlisting}
a = 5
b = 8
I'm the child !
Now, a = 10 in the parent as in the child
Now, b = 10 in the parent as in the child
PID = 2216
PPID = 2215
Sum a + b is 20.
Let's do a ps to see which process is currenlty running !

CODES D'ÉTAT DE PROCESSUS 
Voici les différentes valeurs que les indicateurs de sortie s, stat et state (en-tête « STAT » ou « S ») afficheront pour décrire l'état d'un processus :

D    en sommeil non interruptible (normalement entrées et sorties) ;
R    s'exécutant ou pouvant s'exécuter (dans la file d'exécution) ;
S    en sommeil interruptible (en attente d'un événement pour finir) ;
T    arrêté, par un signal de contrôle des tâches ou parce qu'il a été tracé ;
W    pagination (non valable depuis le noyau 2.6.xx) ;
X    tué (ne devrait jamais être vu) ;
Z    processus zombie (<defunct>), terminé mais pas détruit par son parent.

Pour les formats BSD et quand le mot-clé stat est utilisé, les caractères supplémentaires suivants peuvent être affichés :

<    haute priorité (non poli pour les autres utilisateurs) ;
N    basse priorité (poli pour les autres utilisateurs) ;
L    avec ses pages verrouillées en mémoire (pour temps réel et entrées et sorties personnalisées) ;
s    meneur de session ;
l    possède plusieurs processus légers (« multi-thread », utilisant CLONE\_THREAD comme NPTL pthreads le fait) ;
+    dans le groupe de processus au premier plan.

Ceci est le process parent et le PID est : 2215
PID = 2215
PPID = 28756
Value of vfork is 2216.
Sum a + b is 20.
Let's do a ps to see which process is currenlty running !
Terminated
\end{lstlisting}
\subsection{Code prouvant que le parent est mis en pause}
\begin{lstlisting}
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

/**
 vfork() affiche le contenu du 'if{} else{}' deux fois, d'abord dans l'enfant, puis dans le parent.
 Vu que les deux processus partagent le même espace d'adressage, la première sortie contient la valeur $
 Dans le bloc if else, le processus enfant est exécuté en premier car il bloque le processus parent lor$
 */
int main()
{
    pid_t pid = vfork();  //creating the child process

    printf("Process parent avant le 'if{} else{}': %d\n", getpid());

    if (pid == 0)
    {  // Est-ce le process fils ?
        printf("Ceci est le process fils et le PID est : %d\n\n", getpid());
        exit(0);
    }
    else if (pid > 0)
    {  // Est-ce le process parent ?
        printf("Ceci est le process parent et le PID est : %d\n", getpid());
    }
    else
    { // Y a-t-il eu une erreur lors de la création du process fils ?
        printf("Problème durant le fork\n");
        exit(EXIT_FAILURE);
    }
    return 0;
}
\end{lstlisting}
\subsection{Résultat}
\begin{lstlisting}
Process parent avant le 'if{} else{}': 6666
Ceci est le process fils et le PID est : 6666

Process parent avant le 'if{} else{}': 6664
Ceci est le process parent et le PID est : 6664
\end{lstlisting}







%-------------------------------------------------------------------------
%	CLONE()
%-------------------------------------------------------------------------
\newpage
\section{
    \begin{LARGE}
        clone()
    \end{LARGE}
}\label{clone()}

\subsection{Qu'est-ce}\label{definitionCLONE}
\textbf{clone()} crée un nouveau processus. La fonction \textbf{clone()} a le même effet que \textbf{fork()}, sauf qu'il permet, si l'on le souhaite, de choisir si le processus enfant partage l'espace d'adressage du parent ou non.
\\Contrairement à fork(), cet appel système fournit un contrôle plus précis sur les éléments de contexte d'exécution. Il est partagé entre le processus appelant et le processus enfant.  Cet appel système permet également au nouveau processus enfant d'être placé dans des espaces de noms.
\\\\Quand le processus fils est créé, avec clone(), il exécute la fonction fn(arg) de l'application. (Ceci est différent de fork(2) avec lequel l'exécution continue dans le fils au point de l'appel fork(2)) L'argument fn est un pointeur sur la fonction appelée par le processus fils lors de son démarrage. L'argument arg est transmis à la fonction fn lors de son invocation.
\\\\Quand la fonction fn(arg) revient, le processus fils se termine. La valeur entière renvoyée par fn est utilisée comme code de retour du processus fils. Ce dernier peut également se terminer de manière explicite en invoquant la fonction exit(2) ou après la réception d'un signal fatal.
\\\\L'argument *stack indique l'emplacement de la pile utilisée par le processus fils. Comme les processus fils et appelant peuvent partager de la mémoire, il n'est généralement pas possible pour le fils d'utiliser la même pile que son père. Le processus appelant doit donc préparer un espace mémoire pour stocker la pile de son fils, et transmettre à clone() un pointeur sur cet emplacement. Les piles croissent vers le bas sur tous les processeurs implémentant Linux (sauf le HP PA), donc *stack doit pointer sur la plus haute adresse de l'espace mémoire prévu pour la pile du processus fils.
\\\\L'octet de poids faible de flags contient le numéro du signal de terminaison qui sera envoyé au père lorsque le processus fils se terminera. Si ce signal est différent de SIGCHLD, le processus parent doit également spécifier les options \_\_WALL ou \_\_WCLONE lorsqu'il attend la fin du fils avec wait(2). Si aucun signal n'est indiqué, le processus parent ne sera pas notifié de la terminaison du fils. 
\\\\Les \textit{flags} permet également de préciser ce qui sera partagé entre le père et le fils, en effectuant un OU binaire entre zéro ou plusieurs des constantes suivantes: \url{http://manpagesfr.free.fr/man/man2/clone.2.html}

\subsection{Déclaration de clone(2)}
\begin{lstlisting}
#define _GNU_SOURCE
#include <sched.h>

int clone(int (*fn)(void *), void *stack, int flags, void *arg, ...
/* pid_t *parent_tid, void *tls, pid_t *child_tid */ );
\end{lstlisting}

\subsection{Historique}
Peut-être que Linux aurait dû avoir un appel système de création de threads - Linux aurait alors pu s'épargner la douleur de la première implémentation de pthread pour Linux. (Beaucoup d'erreurs ont été commises sur le chemin du NPTL.) Linux aurait dû apprendre de Solaris/SVR4, où l'émulation des sockets BSD via libsocket au-dessus de STREAMS s'est avérée être une erreur qui a pris beaucoup de temps et beaucoup d'argent à corriger . L'émulation d'une API à partir d'une autre API avec des décalages d'impédance est généralement au mieux difficile.
\\\\Depuis lors, clone(2) est devenu un couteau suisse - il a évolué pour avoir des fonctionnalités d'entrée dans les zones/prison, mais seulement en quelque sorte : Linux n'a pas de zones/prison appropriées, à la place, Linux a ajouté de nouveaux drapeaux clone(2) à pour indiquer les espaces de noms qui ne doivent pas être partagés avec le parent. Et au fur et à mesure que de nouveaux drapeaux clone(2) liés au conteneur sont ajoutés, l'ancien code pourrait souhaiter les avoir utilisés... il faudra modifier et reconstruire le monde appelant clone(2), et ce n'est décidément pas élégant.


\subsection{Fonctionnement}
Quand le processus enfant est créé par  la  fonction  wrapper  clone(), il  débute  son exécution  par  un  appel  à  la  fonction  vers  laquelle pointe l'argument fn (cela est différent de fork(2), pour lequel l'exécution continue dans le processus enfant  à  partir du  moment  de l'appel de fork(2)). L'argument arg est passé comme argument de la fonction fn.
\\\\Quand la fonction fn(arg) renvoie, le processus  enfant  se  termine. La  valeur  entière renvoyée  par  fn  est  utilisée comme code de retour du processus enfant. Ce dernier peut également se terminer de manière explicite en invoquant la fonction exit(2)  ou  après  la réception d'un signal fatal.
\\\\L'argument  stack indique l'emplacement de la pile utilisée par le processus enfant. Comme les processus enfant et appelant peuvent partager de la mémoire, il n'est généralement pas possible  pour l'enfant d'utiliser la même pile que son parent. Le processus appelant doit donc préparer un espace mémoire pour stocker la pile de son enfant, et transmettre à clone un  pointeur sur cet emplacement. Les piles croissent vers le bas sur tous les processeurs implémentant Linux (sauf le HP PA), donc stack doit pointer sur la plus haute  adresse  de l'espace  mémoire prévu pour la pile du processus enfant. Remarquez que clone() ne fournit aucun moyen pour que l'appelant puisse informer le noyau de la taille de  la  zone  de  la pile.

\subsection{particularités}
L'appel  système  clone3()  fournit  un  sur-ensemble  de  la fonctionnalité de l'ancienne interface de clone(). Il offre également un certain nombre d'améliorations de l'API dont : un  espace  pour  des  bits d'attributs  supplémentaires, une séparation plus propre dans l'utilisation de plusieurs paramètres et la possibilité d'indiquer la taille de la zone de la pile de l'enfant.
\\\\Comme  avec fork(2), clone3() renvoie à la fois au parent et à l'enfant. Il renvoie 0 dans le processus enfant et il renvoie le PID de l'enfant dans le parent.
\\\\Le paramètre cl\_args de clone3() est une structure ayant la forme suivante :

\begin{lstlisting}
struct clone_args {
               u64 flags;        /* Masque de bit d'attribut */
               u64 pidfd;        /* Où stocker le descripteur de fichier du PID
                                    (pid_t *) */
               u64 child_tid;    /* Où stocker le TID enfant,
                                    dans la mémoire de l'enfant's memory (pid_t *) */
               u64 parent_tid;   /* Où stocker le TID enfant,
                                    dans la mémoire du parent's memory (int *) */
               u64 exit_signal;  /* Signal à envoyer au parent quand
                                    l'efant se termine */
               u64 stack;        /* Pointeur vers l'octet le plus faible de la pile */
               u64 stack_size;   /* Taille de la pile */
               u64 tls;          /* Emplacement du nouveau TLS */
               u64 set_tid;      /* Pointeur vers un tableau pid_t
                                    (depuis Linux 5.5) */
               u64 set_tid_size; /* Nombre d'éléments dans set_tid
                                    (depuis Linux 5.5) */
               u64 cgroup;       /* Descripteur de fichier du cgroup cible
                                    de l'enfant (depuis Linux 5.7) */
           };
\end{lstlisting}
Le paramètre size fourni à clone3() doit être initialisé à la taille de  cette  structure (l'existence   du   paramètre  size  autorise  des  extensions  futures  de  la  structure clone\_args).
\\\\La pile du processus enfant est indiquée avec cl\_args.stack, qui pointe  vers  l'octet  le plus faible de la zone de la pile, et avec cl\_args.stack\_size, qui indique la taille de la pile en octets. Si l'attribut CLONE\_VM est indiqué (voir ci-dessous), une pile  doit  être explicitement allouée et indiquée. Sinon, ces deux champs peuvent valoir NULL et 0, ce qui amène l'enfant à utiliser la même zone de pile que son parent (dans  l'espace  d'adressage virtuel de son propre enfant).

\begin{large}
    Équivalence entre les paramètres de clone() et de clone3()
\end{large}
\begin{table}[ht]
\caption{clone() vs clone3()} % title of Table
\centering % used for centering table
\begin{tabular}{c c c } % centered columns (4 columns)
\hline\hline %inserts double horizontal lines
clone() & clone3() & Notes \\ [0.5ex] % inserts table
%heading
\hline % inserts single horizontal line
--- & Champ cl\_args &  \\ % inserting body of the table
attributs \& ~0xff & attributs & Pour la plupart des attributs ; détails ci-dessous \\
parent\_tid & pidfd & Voir CLONE\_PIDFD \\
child\_tid & child\_tid & Voir CLONE\_CHILD\_SETTID \\
parent\_tid & parent\_tid & Voir CLONE\_PARENT\_SETTID \\
child\_tid & child\_tid & Voir CLONE\_CHILD\_SETTID \\
attributs \& 0xff & exit\_signal \\
pile & pile \\
--- & stack\_size \\
tls & tls & Voir CLONE\_SETTLS \\
--- & set\_tid \\
--- & set\_tid\_size \\
--- & cgroup & Voir CLONE\_INTO\_CGROUP \\ [1ex] % [1ex] adds vertical space
\hline %inserts single line
\end{tabular}
\label{table:nonlin} % is used to refer this table in the text
\end{table}
\\\\\\Signal de fin de l'enfant
\\Quand  le  processus enfant se termine, un signal peut être envoyé au parent. Le signal de fin  est  indiqué  dans  l'octet  de   poids   faible de   flags (clone())   ou   dans cl\_args.exit\_signal (clone3()). Si ce signal est différent de SIGCHLD, le processus parent doit également spécifier les options  \_\_WALL  ou  \_\_WCLONE lorsqu'il  attend  la  fin  de l'enfant  avec  wait(2). Si aucun signal n'est indiqué (donc zéro), le processus parent ne sera pas notifié de la terminaison de l'enfant.

\begin{itemize}
    \item
        \begin{description}
            \item[L'espace d'adressage] est dupliqué
            \item[Le processus enfant] est un duplicata exact du processus qui appelle vfork() (le processus parent), à l'exception de ce qui suit :
        \end{description}
        \begin{itemize}
            \item[$\ast$] Le processus enfant a un ID de processus (PID) unique, qui ne correspond à aucun ID de groupe de processus actif.
            \item[$\ast$] L'enfant a sa propre copie de la TDFO du parent. Chaque descripteur de fichier dans l'enfant fait référence au même descripteur de fichiers ouverts que le descripteur de fichier correspondant dans le parent.
            \item[$\ast$] L'enfant a sa propre copie des flux de répertoires ouverts du parent. Le flux de répertoires ouverts de chaque enfant peut partager le positionnement du flux de répertoires avec le flux de répertoires du parent correspondant.
            \item[$\ast$] L'enfant n'hérite d'aucun verrou de fichier précédemment défini par le parent.
            \item[$\ast$] Le processus enfant n'a pas d'alarmes définies (semblable aux résultats d'un appel à alarm() avec une valeur d'argument de 0).
            \item[$\ast$] L'enfant n'a pas de signaux en attente.
            \item[$\ast$] Les minuteries d'intervalle sont réinitialisées dans le processus enfant.
            \item[$\ast$] Ces éléments sont mis à 0 dans le fils : tms\_utime, tms\_stime, tms\_cutime, tms\_cstime   
        \end{itemize}
\end{itemize}
\begin{large}
    Valeur de retour
\end{large}
 En cas de réussite, le TID du processus enfant est renvoyé dans le thread  d'exécution  de
       l'appelant.  En  cas  d'échec, -1 est renvoyé dans le contexte de l'appelant, aucun enfant
       n'est créé, et errno contiendra le code d'erreur.

\subsection{Problèmes éventuels}
Les versions de la bibliothèque C GNU jusqu'à la 2.24 comprise  contenaient  une  fonction enveloppe  pour  getpid(2) qui effectuait un cache des PID. Ce cache nécessitait une prise en charge par l'enveloppe de clone() de la glibc, mais des limites  dans  l'implémentation faisaient  que  le  cache  pouvait  ne  pas  être  à jour sous certaines circonstances. En particulier, si un signal était distribué à un enfant juste après l'appel à clone(), alors un  appel à getpid(2) dans le gestionnaire de signaux du signal pouvait renvoyer le PID du processus appelant (le parent), si l'enveloppe de clone n'avait toujours pas eu  le temps de  mettre le cache de PID à jour pour l'enfant. (Ce point ignore le cas où l'enfant a été créé en utilisant CLONE\_THREAD, quand getpid(2) doit renvoyer la même valeur pour l'enfant et pour le processus qui a appelé clone(), puisque l'appelant et l'enfant se trouvent dans le même groupe de threads. Ce problème de cache n'apparaît pas non plus  si  le  paramètre flags  contient  CLONE\_VM.)  Pour  obtenir  la  véritable  valeur, il peut être nécessaire d'utiliser quelque chose comme ceci :
\begin{lstlisting}
           #include <syscall.h>

           pid_t mypid;

           mypid = syscall(SYS_getpid);
\end{lstlisting}
\\\\Suite à un problème de cache ancien, ainsi qu'à d'autres problèmes traités dans getpid(2), la fonctionnalité de mise en cache du PID a été supprimée de la glibc 2.25.

\subsection{Code}

\begin{lstlisting}
// Il est nécessaire de définir \_GNU_SOURCE pour avoir accès à clone(2) et CLONE\_*

#define _GNU_SOURCE
#include <sched.h>
#include <sys/syscall.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

/**
 child
 */
static int child_func(void* arg) {
    char* buffer = (char*)arg;
    printf("Child sees buffer = \"%s\"\n", buffer);
    strcpy(buffer, "hello from child");
    return 0;
}

/**
 Ici, clone() est utilisé de deux manières, une fois avec le drapeau CLONE_VM et une fois sans.
 Un buffer est passé dans le processus enfant, et le processus enfant y écrit une chaîne.
 Une taille de pile est ensuite allouée pour le processus enfant et une fonction qui vérifie si nous ex$
 De plus, un buffer de 100 octets est créé dans le processus parent et une chaîne y est copiée, puis, l$

 Lorsque d'une exécution sans l'argument vm,
 le drapeau CLONE\_VM n'est pas actif et la mémoire virtuelle du processus parent est clonée dans le pro$
 Le processus enfant peut accéder au message passé par le processus parent dans le tampon,
 mais tout ce qui est écrit dans le tampon par l'enfant n'est pas accessible par processus parent.
 */
int main(int argc, char** argv) {
    // Alloue un stack pour la tâche du fils
    const int STACK_SIZE = 65536;
    char* stack = malloc(STACK_SIZE);
    if (!stack) { // Si 'stack' n'a pas été correctement créé
        perror("malloc");
        exit(1);
    }

    // Lorsqu'il est appelé avec l'argument "vm" en ligne de commande, active le flag CLONE_VM.
    unsigned long flags = 0;
    if (argc > 1 && !strcmp(argv[1], "vm")) {

        /**
         int clone(int (*fn)(void *), void *child_stack,
                   int flags, void *arg, ...
                   pid_t *ptid, struct user_desc *tls, pid_t *ctid );
         */

        /**
         Lorsque le processus enfant est créé avec clone(), il exécute la fonction fn(arg).
         (Cela diffère de fork(2), où l'exécution continue dans le fils à partir du point d'appel de fo$
         L'argument fn est un pointeur vers une fonction qui est appelée par le processus fils au début$
         */
        /**
         CLONE_VM (depuis Linux 2.0)
                      Si CLONE_VM est défini, le parent et l'enfant
                      seront exécuté dans le même espace mémoire. En particulier,
                      les écritures mémoire effectuées par le parent ou par l'
                      enfant sont également visibles dans l'autre processus.
                      De plus, tout mappage ou démappage de mémoire effectué avec
                      mmap(2) ou munmap(2) par le processus enfant ou appelant également
                      affecte l'autre processus.
                      Si CLONE_VM n'est pas défini, le processus enfant s'exécute dans un
                      copie séparée de l'espace mémoire du processus appelant
                      au moment de l'appel de clone. Les écritures effectuées par
                      les mappages/démappages effectués par la mémoire de l'un des processus ne
                      n'affecte pas l'autre, comme avec fork(2).

                      Si l'indicateur CLONE_VM est spécifié et l'indicateur CLONE_VFORK
                      n'est pas spécifié, alors toute autre pile de signaux qui a été
                      établie par sigaltstack(2) est effacée dans l'enfant.
         */
        flags |= CLONE\_VM; // 'flags' vaudra 'CLONE\_VM' ou non
    }

    char buffer[100];
    strcpy(buffer, "hello from parent"); // Ecrit 'hello from parent' dans le buffer
    // Clone le processus père
    // Seul appel à 'clone'. Pour avoir les différentes exécutions, il faut ajouter 'vm' comme argument$
    // Vu que lorsque CLONE\_VM est défini, l'espace d'adressage mémoiire est partaé,
    // le buffer est le même pour le père et pour le fils, donc, le fils override ce que le père a écri$
    if (clone(child\_func, stack + STACK_SIZE, flags | SIGCHLD, buffer) == -1) {
        perror("clone");
        exit(1);
    }

    int status;
    if (wait(&status) == -1) {
        perror("wait");
        exit(1);
    }

    printf("Child exited with status %d. buffer = \"%s\"\n", status, buffer);
    return 0;
}
\end{lstlisting}

\subsection{Résultats}
\subsubsection{./clone}
\begin{lstlisting}
Child sees buffer = "hello from parent"
Child exited with status 0. buffer = "hello from parent"
\end{lstlisting}

\subsubsection{./clone vm}
\begin{lstlisting}
Child sees buffer = "hello from parent"
Child exited with status 0. buffer = "hello from child"
\end{lstlisting}








%----------------------------------------------------------------------------------------
%	DISCUSSION
%----------------------------------------------------------------------------------------

\section{Aller plus loin}
\\\\L'ajout de la fonction forkall() au standard a été considéré et rejeté. La fonction forkall() permet à tous les threads du parent d'être dupliqués dans l'enfant. Ceci reproduit essentiellement l'état du parent chez l'enfant. Cela permet aux threads de l'enfant de poursuivre le traitement et permet de préserver les verrous et l'état sans code pthread\_atfork() explicite.
Le processus appelant doit s'assurer que l'état de traitement des threads qui est partagé entre le parent et l'enfant (c'est-à-dire les descripteurs de fichiers ou la mémoire MAP\_SHARED) se comporte correctement après forkall(). Par exemple, si un thread lit un descripteur de fichier dans le parent lorsque forkall() est appelée, alors deux threads (un dans le parent et un dans le child) lisent le fichier filedescriptor après la forkall(). Si ce n'est pas un comportement souhaité, le processus parent doit se synchroniser avec de tels threads avant d'appeler forkall().

\\\\Les fonctions forkx() et forkallx() acceptent un argument flags constitué d'un OU inclusif bit à bit de zéro ou plus des drapeaux suivants, qui sont définis dans l'en-tête sys/fork.h
\\\\FORK\_NOSIGCHLD
Ne postez pas de signal SIGCHLD au processus parent lorsque le processus enfant se termine, quelle que soit la disposition du signal SIGCHLD dans le parent. Les signaux SIGCHLD sont toujours possibles pour les actions d'arrêt et de poursuite du contrôle des tâches si le parent les a demandés.
\\\\FORK\_WAITPID
Ne permettez pas que les wait-for-multiple-pids par le parent, comme dans wait(), waitid(P\_ALL ), ou waitid(P\_PGID), récolter l'enfant et ne permettez pas que l'enfant soit récolté automatiquement en raison de la disposition du signal SIGCHLD configuré pour être ignoré dans le parent. Seule une attente spécifique pour l'enfant, comme dans waitid (P\_PID, pid), est autorisée et elle est requise, sinon lorsque l'enfant sortira, il restera un zombie jusqu'à ce que le parent quitte.
Si l’argument des flags est à 0, alors forkx() aura le même comportement que fork() et forkallx() aura le même comportement que forkall().

%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\section{Sources}
\printbibliography % Output the bibliography
\url{https://man7.org/linux/man-pages/man2/clone.2.htmll}\\
\url{https:://cpp.hotexamples.com/fr/examples/-/-/vfork/cpp-vfork-function-examples.htmll}\\
\url{https:://man7.org/linux/man-pages/man2/vfork.2.htmll}\\
\url{https:://www.ibm.com/docs/en/SSLTBW_2.4.0/com.ibm.zos.v2r4.bpxbd00/rvfork.htmm}\\
\url{https:://mindsgrid.com/difference-fork-vfork-exec-clone//}\\
\url{https:://stackoverflow.com/questions/4856255/the-difference-between-fork-vfork-exec-and-clone}\\
\url{https:://prograide.com/pregunta/11064/la-difference-entre-fork-vfork-exec-et-clonee}\\
\url{http://www.unixguide.net/unix/programming/1.1.2.shtml}\\
\url{https:://prograide.com/pregunta/12758/differences-entre-exec-et-fourche}\\
\url{https:://man7.org/linux/man-pages/man2/fork.2.html}\\
\url{https:://techdifferences.com/difference-between-fork-and-vfork.html}\\
\url{https:://www.ibm.com/docs/en/zos/2.4.0?topic=functions-vfork-create-new-process}\\
\url{https:://man7.org/linux/man-pages/man2/fork.2.html}\\
\url{https:://www.linuxjournal.com/article/5211}\\
\url{https:://man7.org/linux/man-pages/man2/clone.2.html}\\
\url{http://www-igm.univ-mlv.fr/~dr/CS/node88.html}\\
\url{https:://gist.github.com/nicowilliams/a8a07b0fc75df05f684c23c18d7db234}\\
\url{https:://fresh2refresh.com/c-programming/c-buffer-manipulation-function/}\\
\url{https:://stackoverflow.com/questions/66548922/can-a-fork-child-determine-whether-it-is-a-fork-or-a-vfork}\\
\url{https:://news.ycombinator.com/item?id=30502392}\\
\url{https:://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/vfork.2.html}\\
\url{http://manpagesfr.free.fr/man/man2/clone.2.html}\\
\url{https:://gist.github.com/alifarazz/d1ccf716131ed3a369fc7d248d910330}\\
\url{https:://linux.die.net/man/2/clone}\\
\url{https:://www.thegeekstuff.com/2012/05/c-mutex-examples/}\\
\url{https:://docs.oracle.com/cd/E26502_01/html/E35303/gen-1.html}\\
\url{https:://mindsgrid.com/difference-fork-vfork-exec-clone/}\\
\url{https:://stackoverflow.com/questions/21205723/how-many-ways-we-can-create-a-process-in-linux-using-c}\\
\url{https:://cpp.hotexamples.com/fr/examples/-/-/vfork/cpp-vfork-function-examples.html}\\
\url{https:://man7.org/linux/man-pages/man2/vfork.2.html}\\
\url{https:://www.ibm.com/docs/en/zos/2.4.0?topic=functions-vfork-create-new-process}\\
\url{https:://mindsgrid.com/difference-fork-vfork-exec-clone/}\\
\url{https:://stackoverflow.com/questions/4856255/the-difference-between-fork-vfork-exec-and-clone}\\
\url{https:://prograide.com/pregunta/11064/la-difference-entre-fork-vfork-exec-et-clone}\\
\url{http://www.unixguide.net/unix/programming/1.1.2.shtml}\\
\url{https:://prograide.com/pregunta/12758/differences-entre-exec-et-fourche}\\
\url{https:://techdifferences.com/difference-between-fork-and-vfork.html}\\
\url{https:://manpages.ubuntu.com/manpages/hirsute/fr/man2/clone.2.html}\\
\url{http://manpagesfr.free.fr/man/man2/clone.2.html}\\
\url{https:://github.com/jeremyong/google-coredumper/issues/14}\\
\url{https:://stackoverflow.com/questions/29264322/mmap-error-on-linux-using-somethingelse}\\


\end{document}