 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Author:
% Léopold Mols
%
% ATTENTION :
% Pour pouvoir bénéficier de la table des matières, des liens,... Il faut compiler plusieurs fois le fichier template.tex au moyen de la commande 'pdflatex fork_vfork_clone.tex'
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[a4paper, 17pt]{extarticle} 
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{blindtext}
\usepackage{biblatex}
\usepackage{selinput}
\usepackage{minted}
\usepackage{csquotes}
\usepackage{xr}
\usepackage[pro]{fontawesome5}
\usepackage[bookmarks,bookmarksnumbered]{hyperref}
\hypersetup{
    colorlinks = true,
    linkcolor = blue,
    anchorcolor = red,
    citecolor = blue}
\AddToHook{cmd/section/before}{\clearpage}
%\usepackage{hyperref}
%\AddToHook{cmd/subsection/before}{\clearpage}

\lstset{
  aboveskip=3mm,
  belowskip=-2mm,
  basicstyle=\footnotesize,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  deletekeywords={...},
  escapeinside={\%*}{*)},
  extendedchars=true,
  framexleftmargin=16pt,
  framextopmargin=3pt,
  framexbottommargin=6pt,
  frame=tb,
  keepspaces=true,
  language=C,
  literate=
  {²}{{\textsuperscript{2}}}1
  {⁴}{{\textsuperscript{4}}}1
  {⁶}{{\textsuperscript{6}}}1
  {⁸}{{\textsuperscript{8}}}1
  {€}{{\euro{}}}1
  {é}{{\'e}}1
  {è}{{\`{e}}}1
  {ê}{{\^{e}}}1
  {ë}{{\¨{e}}}1
  {É}{{\'{E}}}1
  {Ê}{{\^{E}}}1
  {û}{{\^{u}}}1
  {ù}{{\`{u}}}1
  {â}{{\^{a}}}1
  {à}{{\`{a}}}1
  {á}{{\'{a}}}1
  {ã}{{\~{a}}}1
  {Á}{{\'{A}}}1
  {Â}{{\^{A}}}1
  {Ã}{{\~{A}}}1
  {ç}{{\c{c}}}1
  {Ç}{{\c{C}}}1
  {õ}{{\~{o}}}1
  {ó}{{\'{o}}}1
  {ô}{{\^{o}}}1
  {Õ}{{\~{O}}}1
  {Ó}{{\'{O}}}1
  {Ô}{{\^{O}}}1
  {î}{{\^{i}}}1
  {Î}{{\^{I}}}1
  {í}{{\'{i}}}1
  {Í}{{\~{Í}}}1,
  morekeywords={*,...},
  numbers=left,
  numbersep=10pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stepnumber=1,
  tabsize=4,
  title=\lstname,
}

%----------------------------------------------------------------------------------------
%	Début du rapport
%----------------------------------------------------------------------------------------

\title{fork() \\ vfork() \\ clone()} % Report title

\author{Léopold \textsc{Mols}} % Author name(s), add additional authors like: '\& James \textsc{Smith}'

\date{\today}

\begin{document}

\maketitle

\begin{sloppypar}

\begin{center}
	\begin{tabular}{l r}
		Année: & SYSG6 Q2 2021-2022 \\ % Date the experiment was performed
		Professeur: & Mme \textsc{Bastreghi} % Professeur/supervisor
	\end{tabular}
\end{center}

\tableofcontents

\section{
    \LARGE
        Que sont-ils ?
}
fork(), vfork() et clone() permettent de créer des process s'exécutant sur un OS.
\\\\
Au démarrage d'un système UNIX (norme POSIX (Portable Operating System Interface et le X exprime l'héritage UNIX)), un seul process existe. UNIX est une famille de normes techniques définie depuis 1988 par l'Institute of Electrical and Electronics Engineers (IEEE), et formellement désignée par IEEE 1003. Ces normes ont émergé d'un projet de standardisation des interfaces de programmation des logiciels destinés à fonctionner sur les variantes du système d'exploitation UNIX).
\\Il porte le PID 1 et est souvent nommé 'init'. Tous les autres process du système descendent de ce premier process, via des appels système comme, notamment, fork(), vfork(), forkx(), forkall(), forkallx(), vforkx().


%-------------------------------------------------------------------------
%	FORK()
%-------------------------------------------------------------------------

\section{
    \LARGE
        fork()
}\label{fork()}

\subsection{Qu'est-ce}\label{definitionFORK}
\textbf{fork()} crée un nouveau process en dupliquant le process appelant.\\
\\Le nouveau process est appelé 'process enfant' ou 'fils'. Le process appelant est appelé 'process parent' ou 'père'. Lors de la création du process, la mémoire du père est copiée dans une nouvelle zone mémoire séparée et allouée au fils. Juste après l'exécution de \textbf{fork()}, les deux espaces mémoire ont exactement le même contenu. \\Écritures en mémoire propre, mappages de fichiers (mmap()) et démappages (munmap()) exécutés par l'un des process n'affecte pas l'autre.

\subsection{Déclaration de fork(2)}
\begin{lstlisting}
#include <unistd.h>

pid_t fork(void);
\end{lstlisting}

\subsection{Historique}
Sur les premiers UNIX (1969 $\rightarrow$ années 1990), seul l'appel système fork permet de créer de nouveaux process.
En 1969, fork a été implémenté. Il a été fortement utilisé jusqu'en 1990, année de dépréciation au profit de, notamment, POSIX\_SPAWN.

\subsection{Fonctionnement}
L'appel système fork() fournit une valeur de retour entière qui peut être utilisée pour différencier le père du fils ou indiquer une erreur. La valeur de retour peut être :
\begin{itemize}
  \item un entier supérieur à 0 qui correspond PID du fils, auquel cas nous sommes dans le process père.
  \item 0 auquel cas nous sommes dans le process fils.
  \item -1 qui témoigne une erreur lors de l’exécution de la commande. Dans ce cas, aucun process enfant n'est créé et errno est modifié pour indiquer l'erreur.
\end{itemize}

Il est possible d’interagir entre process de plusieurs manières différentes.
\\Premièrement, il est possible envoyer des signaux. Par exemple, la commande bash 'kill <pid>' permet d'envoyer le signal SIGINT à un process. La majorité des process recevant ce signal se termineront. Si l'on veut envoyer un autre signal, il faut le préciser dans la commande de cette manière : 'kill -<numéro du signal> <pid>'.
Pour éviter qu'un fils devienne un zombie, le père doit l'attendre. Pour ce faire, il peut utiliser la fonction pid\_t wait(int *ptr\_state). La valeur de retour de cette fonction est le pid du fils qui a terminé. Un process devient un zombie lorsque le process se termine, mais que le père n'a pas attendu son fils, c'est-à-dire qu'il n'a, par exemple, pas fait d'appels à wait(). C'est une situation qu'il convient d'éviter absolument car le process ne peut plus s'exécuter mais consomme encore des ressources.
\\On peut également attendre la fin du fils grâce à son pid : pid\_t waitpid(pid\_t pid, int *ptr\_state, int options).

\newpage
\subsection{particularités}
\begin{itemize}
    \item
        \begin{description}
            \item[L'espace d'adressage] est dupliqué, mais uniquement lors de la première modification de ressource grâce à la méthode COW (Copy On Write) et ce, sur les systèmes récents. Auparavant, il était directement dupliqué.
            \\\\La méthode COW trouve son utilisation principale dans le partage de la mémoire virtuelle des process du système d'exploitation : dans la mise en œuvre de l'appel système de bifurcation. Typiquement, le process ne modifie aucune mémoire et exécute immédiatement un nouveau process, remplaçant complètement l'espace d'adressage. Ainsi, il serait inutile de copier toute la mémoire du process pendant une bifurcation, et au lieu de cela, la technique COW est utilisée.
            \\La méthode COW peut être mise en œuvre efficacement en utilisant le tableau des pages en marquant certaines pages de mémoire comme étant en lecture seule et en comptant le nombre de références à la page. Lorsque des données sont écrites sur ces pages, le noyau du système d'exploitation intercepte la tentative d'écriture et alloue une nouvelle page physique initialisée avec les données de COW, bien que l'allocation puisse être ignorée s'il n'y a qu'une seule référence. Le noyau met ensuite à jour la table des pages avec la nouvelle page, décrémente le nombre de références et effectue l'écriture. La nouvelle allocation garantit qu'un changement dans la mémoire d'un process n'est pas visible dans un autre.
            \\La technique de COW peut être étendue pour prendre en charge une allocation efficace de mémoire en ayant une page de mémoire physique remplie de zéros. Lorsque la mémoire est allouée, toutes les pages renvoyées se réfèrent à la page de zéros et sont toutes marquées COW. De cette façon, la mémoire physique n'est pas allouée pour le process tant que les données ne sont pas écrites, ce qui permet aux process de réserver plus de mémoire virtuelle que de mémoire physique et d'utiliser la mémoire avec modération, au risque de manquer d'espace d'adressage virtuel. L'algorithme combiné est similaire à la pagination à la demande.
        \end{description}
    \item
        \begin{description}
            \item[Le process enfant] est une copie presque'exacte du process parent. Notamment, ces éléments diffèrent :
            \begin{itemize}
                \item[$\ast$] L'enfant a son propre ID de process, ID unique
                \item[$\ast$] L'enfant n'hérite pas des threads de son père et n'en crée pas de nouveaux.
                \\('cat /proc/\$PID/status' -> section 'Threads' ou 'Thr')
                \item[$\ast$] L'enfant n'hérite pas des verrous de mémoire de son parent
                \\('ps -aux' pour voir que l'état du père est 'SLl+'. Le 'L' indique que ses pages sont verrouillées en mémoire. L'état du fils indique qu'il n'a pas de pages verrouillées en mémoire.).
                \item[$\ast$] La table des signaux est remise à 0 pour l'enfant : ceci peut être faux en fonction de l'environnement (sur PopOS, MacOS ARM, MacOS Intel, machine virtuelle sur Mac,..., la table des signaux n'est pas remise à 0).
%                \item[$\ast$] L'enfant n'hérite pas des sémaphores de son parent.
%                \item[$\ast$] L'enfant n'hérite pas des verrous d'enregistrement associés au process parent
%                \item[$\ast$] L'enfant n'hérite pas des minuteries de son parent 
%                \item[$\ast$] L'enfant n'hérite pas des E/S asynchrones en suspens ni des contextes d'E/S asynchrones de son parent
            \end{itemize}
        \end{description}
\end{itemize}

\subsection{Problèmes éventuels}
Au vu du fait que fork() duplique l'espace d'adressage , cela représent un risque de remplir la mémoire, ralentir l'ordinateur et empêcher la création de nouveaux process si, par exemple, la mémoire est pleine de pages non évincables.
\\\\Lors de son implémentation, fork() n'était pas utilisable par les développeurs. Depuis que les développeurs d'Unix l'ont ouvert au user-land (pour que les développeurs puissent l'utiliser dans leurs logiciels), cela a permis de développer des logiciels qui fonctionnent sur plusieurs process et non sur un seul et même process. Cela les a rendus plus productifs, peut-être beaucoup plus. Le prix que les créateurs d'Unix ont payé pour cette pratique était la nécessité de copier les espaces d'adressage. Étant donné qu'à l'époque, les programmes et les process étaient petits, le manque de possibilité de répartir des tâches sur plusieurs process était facile à négliger ou à ignorer. Mais maintenant, les process ont tendance à être très importants et multithreads, ce qui rend extrêmement coûteux la copie même de l'espace d'adressage d'un parent.

\subsection{Suppléments}
fork1(), forkall(), forkx(), forkallx()
Les fonctions forkx() et forkallx() acceptent un argument flags composé d'un OU inclusif au niveau du bit de zéro ou plusieurs des drapeaux suivants, qui sont définis dans l'en-tête sys/fork.h
Si l'argument flags est 0, forkx() est identique à fork() et forkallx() est identique à forkall().

\subsection{Code prouvant que l'espace d'adressage n'est pas partagé, que les threads ne sont pas transmis au fils et que les verrous de mémoire ne sont pas transmis au fils}
\begin{normalsize}
Ce \hyperref[codeFork]{code} effectue une addition de 2 variables par le fils pour prouver que seules les variables du fils sont modifiées puisque le père et le fils ne partagent pas le même espace d'adressage.
\\Il prouve également que les threads créés par le père ne sont pas transmis au fils ou recréés pour être attribués au fils.
\\ Enfin, il prouve que les verrous de mémoire ne sont pas transmis au fils.
\end{normalsize}

\newpage
\subsection{Resultat}
\begin{lstlisting}
CODES D'ÉTAT DE PROCESSUS 
Voici les différentes valeurs que les indicateurs de sortie s, stat et state (en-tête "STAT" ou "S") afficheront pour décrire l'état d'un processus :

D    en sommeil non interruptible (normalement entrées et sorties) ;
R    s'exécutant ou pouvant s'exécuter (dans la file d'exécution) ;
S    en sommeil interruptible (en attente d'un événement pour finir) ;
T    arrêté, par un signal de contrôle des tâches ou parce qu'il a été tracé ;
W    pagination (non valable depuis le noyau 2.6.xx) ;
X    tué (ne devrait jamais être vu) ;
Z    processus zombie (<defunct>), terminé mais pas détruit par son parent.

Pour les formats BSD et quand le mot-clé stat est utilisé, les caractères supplémentaires suivants peuvent être affichés :

<    haute priorité (non poli pour les autres utilisateurs) ;
N    basse priorité (poli pour les autres utilisateurs) ;
L    les pages du processus sont verrouillées en mémoire;
s    meneur de session ;
l    possède plusieurs processus légers ("multi-thread", utilisant CLONE\_THREAD comme NPTL pthreads le fait) ;
+    dans le groupe de processus au premier plan.






PID du père = 98479
Ces 2 variables sont créées et initialisées par le père :
a = 5
b = 8

De la mémoire a été réservée en RAM par le père
Pour continuer le programme, entrez 'continue' ou 'c' : c

Ceci est avant que le père ne crée un thread

Pour continuer le programme, entrez 'continue' ou 'c' : c
Fonction liée à la création de thread appelée 
Fonction liée à la création de thread appelée 
Fonction liée à la création de thread appelée 
Ceci est le process parent et le PID est : 98479
Le processus fils vient d'être créé. La suite est affichée par le fils.
Maintenant, a = 10 et ce, uniquement dans l'espace d'adressage du fils
Maintenant, b = 10 et ce, uniquement dans l'espace d'adressage du fils
PID (du fils, donc) = 98483
PID du père = 98479
a + b = 20.

Dans une autre fenêtre de terminal, entrez la commande 'ps -aux' pour voir quel process est en cours et plus d'informations à leurs propos !

Sous la section 'Status', vous pouvez voir que le statut du père est 'SLl+'.
Le 'L' signifie que de la mémoire est verrouillée en RAM par le process !
Le 'l' signifie que le proccess possède plusieurs processus légers : les threads qu'il a créés

RSS signifie Resident Set Size et montre la quantité de RAM utilisée au moment de la sortie de la commande. Il convient également de noter qu'il affiche toute la pile de mémoire physiquement allouée.

VSZ est l'abréviation de Virtual Memory Size. C'est la quantité totale de mémoire à laquelle un processus peut hypothétiquement accéder. Il tient compte de la taille du binaire lui-même, de toutes les bibliothèques liées et de toutes les allocations de pile ou de tas.


Dans une autre fenêtre de terminal, entrez la commande 'cat /proc/$PID/status' pour voir les informations du process !


Le fils est en train de tourner à l'infini via un 'while(1)' pour prouver qu'il n'est pas en sommeil (cfr 'ps -aux'). Pour l'arrêter, dans une autre fenêtre de terminal, entrez la commande 'kill $PID' !


Ce signal indique qu'un processus fils s'est arrêté ou a fini son exécution. Par défaut ce signal est ignoré. SIGHUP : numéro 1

Le fils est terminé
PID (du père, donc) = 98479
PPID (id du process à l'origine de la création du programme) = 3126
a + b = 13.
Vu que a + b = 20 dans le fils et que a + b = 13 dans le père, cela prouve que l'espace d'adressage d'un process créé au moyen de fork n'est pas celui du père car il a été dupliqué par rapport à celui du père. Chaque process a donc ses propres variables,...

Dans une autre fenêtre de terminal, entrez la commande 'ps -aux' pour voir quel process est en cours et plus d'informations à leurs propos !

Memory unlocked in RAM


Le programme ne se termine pas pour laisser le temps de faire un 'ps -aux' et voir quels process sont en cours d'exécution et leurs états. Pour le terminer, faites un 'kill $PID' dans une autre fenêtre de terminal ou faites un CTRL + C ici
After Thread
Terminated
\end{lstlisting}

\subsection{Code prouvant que l'espace d'adressage n'est partagé en appelant plusieurs fois fork}
\begin{normalsize}
Ce \hyperref[codeForkMoreprocesses]{code} effectue plusieurs fois l'appel à fork() pour prouver qu'à chaque duplication de process par ce moyen, un nouvel espace d'adressage sera alloué au process fils.
\end{normalsize}

\subsection{Resultat}
\begin{lstlisting}
CODES D'ÉTAT DE PROCESSUS 
Voici les différentes valeurs que les indicateurs de sortie s, stat et state (en-tête "STAT" ou "S") afficheront pour décrire l'état d'un processus :

D    en sommeil non interruptible (normalement entrées et sorties) ;
R    s'exécutant ou pouvant s'exécuter (dans la file d'exécution) ;
S    en sommeil interruptible (en attente d'un événement pour finir) ;
T    arrêté, par un signal de contrôle des tâches ou parce qu'il a été tracé ;
W    pagination (non valable depuis le noyau 2.6.xx) ;
X    tué (ne devrait jamais être vu) ;
Z    processus zombie (<defunct>), terminé mais pas détruit par son parent.

Pour les formats BSD et quand le mot-clé stat est utilisé, les caractères supplémentaires suivants peuvent être affichés :

<    haute priorité (non poli pour les autres utilisateurs) ;
N    basse priorité (poli pour les autres utilisateurs) ;
L    les pages du processus sont verrouillées en mémoire;
s    meneur de session ;
l    possède plusieurs processus légers ("multi-thread", utilisant CLONE\_THREAD comme NPTL pthreads le fait) ;
+    dans le groupe de processus au premier plan.







Dans une autre fenêtre de terminal, entrez la commande 'top' pour voir quels process sont en cours et plsu d'informations, dont leur utilisation de la mémoire et ce, en temps réel !
 Ceci permettra d'observer que 5 lignes seront créées dans le tableau du résultat de la commande car fork() crée des process à part entière.

Pour continuer le programme, entrez 'continue' ou 'c' : c
PID du père = 98535
Ceci est le process parent et le PID est : 98535
Ceci est le process fils et le PID est : 98536
Ceci est le process parent et le PID est : 98535
Ceci est le process fils et le PID est : 98537
Ceci est le process parent et le PID est : 98535
Ceci est le process fils et le PID est : 98538
Ceci est le process parent et le PID est : 98535
Ceci est le process fils et le PID est : 98539
Ceci est le process parent et le PID est : 98535


Les fils sont en train de tourner à l'infini via un 'while(1)' pour montrer la mémoire qu'ils occupent via la commande 'top' (cfr 'ps -aux'). Pour les arrêter, dans une autre fenêtre de terminal, entrez la commande 'kill {$PID_du_premier_fils..$PID_su_dernier_fils' !

Ceci est le process fils et le PID est : 98540

Les fils sont terminés
PID (du père, donc) = 98535
PPID (id du process à l'origine de la création du programme) = 3126

Vu que lorsque vous tuez 1 process via un autre terminal, l'entrée  liée au process de l'affichage généré par la commande 'top' disparait, cela prouve que chaque process a bien son propre espace d'adressage.

Terminated

\end{lstlisting}



 
 
 
 
 
%-------------------------------------------------------------------------
%	VFORK()
%-------------------------------------------------------------------------
\newpage
\section{
    \LARGE
        vfork()
}\label{vfork()}

\subsection{Qu'est-ce}\label{definitionVFORK}
\textbf{vfork()} est un appel système ou fonction qui crée un nouveau process. La fonction \textbf{vfork()} a le même effet que \textbf{fork()}, sauf que le comportement n'est pas défini si le process créé par \textbf{vfork()} tente d'appeler toute autre fonction avant d'appeler \_exit() ou une des fonctions de la famille exec().
\\\textbf{vfork()} est un cas particulier de \textbf{clone()} que nous verrons plus tard. Il est utilisé pour créer de nouveaux process sans copier les tables de pages du process parent. \textbf{vfork()} diffère de \textbf{fork()} car le père appelant est suspendu jusqu'à ce que l'enfant se termine, ou il fait un appel à une fonction de la famille exec(2). Jusqu'à ce moment-là, l'enfant partage toute la mémoire avec son parent.  Il peut être utile dans les applications qui doivent utiliser le minimum des ressources du système. Le process enfant créé appelle alors immédiatement une fonction de la famille exec() pour se dissocier du père, ce qui changera le statut du père de "en pause" à "en exécution". L'appel \textbf{vfork()} ne diffère de \textbf{fork()} que dans le traitement de l'espace d'adressage virtuel, comme décrit ci-dessus. Les signaux envoyés au parent arrivent après que l'enfant ait libéré la mémoire du parent (c'est-à-dire après sa fin ou après l'appel de à une fonction de la famille exec()).
\\\\Sous Linux, \textbf{fork()} est implémenté en utilisant des pages copy-on-write, donc la seule pénalité encourue par \textbf{fork()} est le temps et la mémoire nécessaire pour dupliquer les tables de pages du parent et pour créer un structure de tâches unique pour l'enfant. Cependant, auparavant, \textbf{fork()} nécessitait de faire une copie complète du l'espace d'adressage du père, souvent inutilement, car généralement immédiatement par la suite, un appel à une fonction de la famille exec() est effectué. Ainsi, pour une plus grande efficacité, BSD a introduit l'appel système \textbf{vfork()}, qui ne copie pas entièrement l"espace d'adressage du père, mais emprunte la mémoire et le fil d'exécution jusqu'à un appel à execve(2) ou une sortie. Le process parent est suspendu pendant que l'enfant utilise ses ressources. L'utilisation de \textbf{vfork()} a été délicate: par exemple, ne pas modifier les données dans le process père dépendait de savoir quelles variables étaient conservées dans un registre et lesquelles ne l'étaient dans le but de savoir lesquelles il était autorisé de modifier.


\subsection{Déclaration de vfork(2)}
\begin{lstlisting}
#include <sys/types.h> 
#include <unistd.h>

pid_t vfork(void);
\end{lstlisting}

\subsection{Historique}
L'appel système vfork() est apparu dans BSD 3.0. Dans BSD 4.4, il est devenu synonyme de fork(). NetBSD l'a réintroduit pour qu'il foncitonne à nouveau en tant que vfork() : voir \url{http://www.netbsd.org/Documentation/kernel/vfork.html}.
\\\\Sous Linux, il fut l'équivalent de fork() jusqu'au noyau 2.2.0-pre-6. Depuis le 2.2.0-pre-9 il s'agit d'un appel système indépendant. Le support dans la bibliothèque a été introduit dans la glibc 2.0.112.
\subsection{Fonctionnement}
Suite à la duplication de process via \textbf{vfork()}, l’espace d’adressage du fils n’est pas une duplication de celui du père comme pour un fork(), mais il sera le même : celui du père. Cela peut permettre de faire en sorte que, si la duplication du process fils s'est correctement déroulée, le père n’aura plus d'utilité parce que le fils aura le même espace d'adressage (cfr. la famille d'exec qui remplace l'espace d'adressage du père lors de leur création).
\\\\\textbf{vfork()}, tout comme \textbf{fork()}, crée un process fils à partir du process appelant.
\textbf{vfork()} est conçu comme un cas particulier de \textbf{clone()}. Il sert à créer un nouveau process sans effectuer de copie de la table des pages mémoire du process père. Ceci peut être utile dans des applications nécessitant une grande rapidité d'exécution, si le fils doit invoquer immédiatement un appel execve().
\\\\\textbf{vfork()} diffère aussi de \textbf{fork()} car le process père reste en pause jusqu'à ce que le fils invoque execve(), ou \_exit(). Le fils partage toute la mémoire avec son père, y compris la pile, jusqu'à ce que execve() soit appelé par le fils. Le process fils ne doit donc pas retourner du père. 
\\\\Donc semblable à l'appel système fork(), vfork() crée également un process enfant identique à son process parent. Cependant, le process enfant suspend temporairement le process parent jusqu'à ce qu'il se termine. En effet, les deux process utilisent le même espace d'adressage ( contient la pile, le pointeur de pile et le pointeur d'instructions).


\subsection{particularités}
\begin{itemize}
    \item
        \begin{description}
            \item[L'espace d'adressage] n'est pas dupliqué, mais partagé entre le père et le fils.
            \end{description}
    \item
        \begin{description}
            \item[Le process enfant] est un duplicata exact du process qui appelle vfork() (le process parent), à l'exception de ce qui suit :
        \end{description}
        \begin{itemize}
            \item[$\ast$] Le process enfant a un ID de process (PID) unique, qui ne correspond à aucun ID de groupe de process actif.
            \item[$\ast$] L'enfant n'hérite pas des threads de son père et n'en crée pas de nouveaux.
            \\('cat /proc/\$PID/status' -> section 'Threads' ou 'Thr')
        \end{itemize}
\end{itemize}
Toutes les pages de manuel vfork(2) vues indiquent que le process parent est arrêté jusqu'à ce que l'enfant quitte/exécute, mais cela est antérieur aux threads. Linux, par exemple, n'arrête que le seul thread du parent qui a appelé vfork(), pas tous les threads du père.

\subsection{Problèmes éventuels}
Il est regrettable que Linux ait ressuscité ce spectre du passé. La page de manuel de BSD indique que cet appel système sera supprimé quand des mécanismes de partage appropriés seront implémentés, et qu'il ne faut pas essayer de tirer profit du partage mémoire induit par vfork(), car dans ce cas, le système fera qu'il se comportera comme fork(2).
\\\\Les détails de la gestion des signaux sont compliqués, et varient suivant les systèmes.
\\\\Lors de l'utilisation de vfork(), il arrive souvent que ce message apparaisse lors de la compilation, ce qui montre, par exemple, que l'exécution diffère d'un système à un autre :
\textit{This system call is deprecated. In a future release, it may begin to return errors in all cases, or may be removed entirely.  It is extremely strongly recommended to replace all uses with fork(2) or, ideally, posix\_spawn(3).} Il indique que vfork() est déprécié (malgré le fait que Linux l'ait ressucité) et qu'il vaut mieux utiliser posix\_spawn puisqu'il est considéré comme son successeur.
\\\\vfork() a un inconvénient : le parent (en particulier : le thread dans le parent qui appelle vfork()) et l'enfant partagent une pile, ce qui nécessite que le parent (thread) soit arrêté jusqu'à ce que l'enfant appelle \_exit() ou une fonction de la famille exec(). (Cela peut être pardonné en raison des longs threads précédents de vfork(2) -- lorsque les threads sont apparus, le besoin d'une pile séparée pour chaque nouveau thread est devenu tout à fait clair et inévitable. La solution pour les threads était d'utiliser une nouvelle pile).

\newpage
\subsection{Code prouvant l'espace d'adressage partagé}
\begin{normalsize}
Ce \hyperref[codeVfork]{code} effectue une addition de 2 variables par le fils pour prouver que les variables du père sont modifiées par le fils puisque le père et le fils partagent le même espace d'adressage.
\\Il prouve également que les threads créés par le père ne sont pas transmis au fils ou recréés pour être attribués au fils.
\end{normalsize}

\subsection{Résultat}
\begin{lstlisting}
CODES D'ÉTAT DE PROCESSUS 
Voici les différentes valeurs que les indicateurs de sortie s, stat et state (en-tête "STAT" ou "S") afficheront pour décrire l'état d'un processus :

D    en sommeil non interruptible (normalement entrées et sorties) ;
R    s'exécutant ou pouvant s'exécuter (dans la file d'exécution) ;
S    en sommeil interruptible (en attente d'un événement pour finir) ;
T    arrêté, par un signal de contrôle des tâches ou parce qu'il a été tracé ;
W    pagination (non valable depuis le noyau 2.6.xx) ;
X    tué (ne devrait jamais être vu) ;
Z    processus zombie (<defunct>), terminé mais pas détruit par son parent.

Pour les formats BSD et quand le mot-clé stat est utilisé, les caractères supplémentaires suivants peuvent être affichés :

<    haute priorité (non poli pour les autres utilisateurs) ;
N    basse priorité (poli pour les autres utilisateurs) ;
L    les pages du processus sont verrouillées en mémoire;
s    meneur de session ;
l    possède plusieurs processus légers ("multi-thread", utilisant CLONE\_THREAD comme NPTL pthreads le fait) ;
+    dans le groupe de processus au premier plan.






PID du père = 98625
Ces 2 variables sont créées et initialisées par le père :
a = 5
b = 8
Pour continuer le programme, entrez 'continue' ou 'c' : c

Ceci est avant que le père ne crée un thread

Pour continuer le programme, entrez 'continue' ou 'c' : c
Fonction liée à la création de thread appelée 
Fonction liée à la création de thread appelée 
Fonction liée à la création de thread appelée 
Le processus fils vient d'être créé. La suite est affichée par le fils.
Maintenant, a = 10 et ce, dans l'espace d'adressage du fils qui est aussi celui du père
Maintenant, b = 10 et ce, dans l'espace d'adressage du fils qui est aussi celui du père
PID (du fils, donc) = 98629
PID du père = 98625
a + b = 20.

Dans une autre fenêtre de terminal, entrez la commande 'ps -aux' pour voir quel process est en cours et plus d'informations à leurs propos !

Sous la section 'Status', vous pouvez voir que le statut du père est 'Dl+'.
Le 'L' signifie que de la mémoire est verrouillée en RAM par le process !
Le 'l' signifie que le proccess possède plusieurs processus légers : les threads qu'il a créés

RSS signifie Resident Set Size et montre la quantité de RAM utilisée au moment de la sortie de la commande. Il convient également de noter qu'il affiche toute la pile de mémoire physiquement allouée.

VSZ est l'abréviation de Virtual Memory Size. C'est la quantité totale de mémoire à laquelle un processus peut hypothétiquement accéder. Il tient compte de la taille du binaire lui-même, de toutes les bibliothèques liées et de toutes les allocations de pile ou de tas.


Dans une autre fenêtre de terminal, entrez la commande 'cat /proc/$PID/status' pour voir les informations du process !


Le fils est en train de tourner à l'infini via un 'while(1)' pour prouver qu'il n'est pas en sommeil (cfr 'ps -aux'). Pour l'arrêter, dans une autre fenêtre de terminal, entrez la commande 'kill 98629' !
Ceci est le process parent et le PID est : 98625
Le fils est terminé
PID (du père, donc) = 98625
PPID (id du process à l'origine de la création du programme) = 3126
a + b = 20.
Vu que a + b = 20 dans le fils et que a + b = 20 dans le père, cela prouve que l'espace d'adressage d'un process créé au moyen de vfork est celui du père car il est partagé avec le père.

Dans une autre fenêtre de terminal, entrez la commande 'ps -aux' pour voir quel process est en cours et plus d'informations à leurs propos !



Le programme ne se termine pas pour laisser le temps de faire un 'ps -aux' et voir quels process sont en cours d'exécution et leurs états. Pour le terminer, faites un 'kill 98625' dans une autre fenêtre de terminal ou faites un CTRL+C ici
Terminated
\end{lstlisting}

\subsection{Code prouvant que le parent est mis en pause}
\begin{normalsize}
Ce \hyperref[codeVforkParentPAUSED]{code} effectue effectue un affichage par le père et par le fils. Le fait que le fils effectue le sien en premier et le père en second prouve que le père est mis en pause car, au vu du fait que le père est mis en pause lors de la duplication de process, le fils prend la main et effectue son affichage avant que le père ne puisse effectuer le sien.
\end{normalsize}

\newpage
\subsection{Résultat}
\begin{lstlisting}

vfork() affiche le contenu du 'if{} else{}' deux fois, d'abord dans l'enfant, puis dans le parent.
Vu que les deux processus partagent le même espace d'adressage, la première sortie contient la valeur du PID correspondant au process fils.
Dans le bloc if else, le processus fils est exécuté EN PREMIER car il bloque le processus parent lors de son exécution, donc, le père est MIS EN PAUSE.


Process fils avant le 'if{} else{}': 14839
Ceci est le process fils et le PID est : 14840
Ceci est le process parent et le PID est : 14839

\end{lstlisting}

\subsection{Code prouvant que l'espace d'adressage est partagé entre un père et son fils même si vfork est exécuté plusieurs fois}
\begin{normalsize}
Ce \hyperref[codeVforkMoreprocesses]{code} effectue plusieurs fois l'appel à vfork() pour prouver qu'à chaque duplication de process par ce moyen, le fils aura accès au même espace d'adressage que le père, donc, ce dernier ne sera pas dupliqué.
\end{normalsize}

\subsection{Résultat}
\begin{lstlisting}
CODES D'ÉTAT DE PROCESSUS 
Voici les différentes valeurs que les indicateurs de sortie s, stat et state (en-tête "STAT" ou "S") afficheront pour décrire l'état d'un processus :

D    en sommeil non interruptible (normalement entrées et sorties) ;
R    s'exécutant ou pouvant s'exécuter (dans la file d'exécution) ;
S    en sommeil interruptible (en attente d'un événement pour finir) ;
T    arrêté, par un signal de contrôle des tâches ou parce qu'il a été tracé ;
W    pagination (non valable depuis le noyau 2.6.xx) ;
X    tué (ne devrait jamais être vu) ;
Z    processus zombie (<defunct>), terminé mais pas détruit par son parent.

Pour les formats BSD et quand le mot-clé stat est utilisé, les caractères supplémentaires suivants peuvent être affichés :

<    haute priorité (non poli pour les autres utilisateurs) ;
N    basse priorité (poli pour les autres utilisateurs) ;
L    les pages du processus sont verrouillées en mémoire;
s    meneur de session ;
l    possède plusieurs processus légers ("multi-thread", utilisant CLONE\_THREAD comme NPTL pthreads le fait) ;
+    dans le groupe de processus au premier plan.







Dans une autre fenêtre de terminal, entrez la commande 'top' pour voir quels process sont en cours et plsu d'informations, dont leur utilisation de la mémoire et ce, en temps réel !

Pour continuer le programme, entrez 'continue' ou 'c' : c
PID du père = 98674
Ceci est le process fils et le PID est : 98675
Ceci est le process fils et le PID est : 98676
Ceci est le process fils et le PID est : 98678
Ceci est le process fils et le PID est : 98679
Ceci est le process fils et le PID est : 98680

Vous pouvez observer que, dans le tableau de la commande 'top', une seule ligne concernant ce programme a été créée. Cela signifie que vfork() a créé des process en créant des threads. A ce stade, les fils créés par vfork ne sont que des threads. Ils deviendront des process lorsque les fils fils appelleront une fonction de la famille exec().



Le fils est en train de tourner à l'infini via un 'while(1)' pour montrer la mémoire utilisée par l'espace des process lié à ce programme (puisque l'espace d'adressage est partagé entre le père et le fils).

Pour l'arrêter, dans une autre fenêtre de terminal, entrez la commande 'kill 98680' !
Ceci est le process parent et le PID est : 98679


Le fils est en train de tourner à l'infini via un 'while(1)' pour montrer la mémoire utilisée par l'espace des process lié à ce programme (puisque l'espace d'adressage est partagé entre le père et le fils).

Pour l'arrêter, dans une autre fenêtre de terminal, entrez la commande 'kill 98679' !
Ceci est le process parent et le PID est : 98678


Le fils est en train de tourner à l'infini via un 'while(1)' pour montrer la mémoire utilisée par l'espace des process lié à ce programme (puisque l'espace d'adressage est partagé entre le père et le fils).

Pour l'arrêter, dans une autre fenêtre de terminal, entrez la commande 'kill 98678' !
Ceci est le process parent et le PID est : 98676


Le fils est en train de tourner à l'infini via un 'while(1)' pour montrer la mémoire utilisée par l'espace des process lié à ce programme (puisque l'espace d'adressage est partagé entre le père et le fils).

Pour l'arrêter, dans une autre fenêtre de terminal, entrez la commande 'kill 98676' !
Ceci est le process parent et le PID est : 98675


Le fils est en train de tourner à l'infini via un 'while(1)' pour montrer la mémoire utilisée par l'espace des process lié à ce programme (puisque l'espace d'adressage est partagé entre le père et le fils).

Pour l'arrêter, dans une autre fenêtre de terminal, entrez la commande 'kill 98675' !
Ceci est le process parent et le PID est : 98674
Les fils sont terminés


Au fur et à mesure que vous killiez les process un à un, vous avez pu observer que la mémoire occupée par le process courant n'a pas diminué, ce qui prouve que l'espace d'adressage est partagé entre un process père et un process fils si le moyen de duplication de process est 'vfork()' !


PID (du père, donc) = 98674

PPID (id du process à l'origine de la création du programme) = 3126

Dans une autre fenêtre de terminal, entrez la commande 'ps -aux' pour voir quel process est en cours et plus d'informations à leurs propos !



Le programme ne se termine pas pour laisser le temps de faire un 'ps -aux' et voir quels process sont en cours d'exécution et leurs états. Pour le terminer, faites un 'kill 98674' dans une autre fenêtre de terminal ou faites un CTRL+C ici. Vous verrez alors dans l'affichage généré par la commande 'top' que la mémoire occupée par le process courant est libérée
Terminated
\end{lstlisting}





%-------------------------------------------------------------------------
%	CLONE()
%-------------------------------------------------------------------------
\newpage
\section{
    \LARGE
        clone()
}\label{clone()}

\subsection{Qu'est-ce}\label{definitionCLONE}
\textbf{clone()} crée un nouveau process. La fonction \textbf{clone()} a le même effet que \textbf{fork()}, sauf qu'il permet, si l'on le souhaite, de choisir si le process enfant partage l'espace d'adressage du parent ou non.
\\Contrairement à \textbf{fork()}, cet appel système fournit un contrôle plus précis sur les éléments de contexte d'exécution. Il est partagé entre le process appelant et le process enfant.
\\\\Quand le process fils est créé, avec clone(), il exécute la fonction fn(arg) de l'application. (Ceci est différe de fork(2) avec lequel l'exécution continue dans le fils au point de l'appel fork(2)) L'argument 'arg' de fn est un pointeur sur la fonction appelée par le process fils lors de son démarrage. 'arg' est transmis à la fonction fn lors de son invocation.
\\\\Quand la fonction fn(arg) retourne, le process fils se termine. La valeur entière renvoyée par fn est utilisée comme code de retour du process fils. Ce dernier peut également se terminer de manière explicite en appelant la fonction exit(2) ou après la réception d'un signal fatal.
\\\\L'argument *stack indique l'emplacement de la pile utilisée par le process fils. Comme les process fils et appelant peuvent partager de la mémoire, il n'est généralement pas possible pour le fils d'utiliser la même pile que son père. Le process appelant doit donc préparer un espace mémoire pour stocker la pile de son fils, et transmettre à clone() un pointeur sur cet emplacement. Les piles croissent vers le bas sur tous les processeurs implémentant Linux (sauf le HP PA), donc *stack doit pointer sur la plus haute adresse de l'espace mémoire prévu pour la pile du process fils.
\\\\L'octet de poids faible de flags contient le numéro du signal de terminaison qui sera envoyé au père lorsque le process fils se terminera. Si ce signal est différent de SIGCHLD, le process parent doit également spécifier les options \_\_WALL ou \_\_WCLONE lorsqu'il attend la fin du fils avec wait(2). Si aucun signal n'est indiqué, le process parent ne sera pas notifié de la terminaison du fils. 
\\\\Les \textit{flags} permettent également de préciser ce qui sera partagé entre le père et le fils, en effectuant un OU binaire entre zéro ou plusieurs de ces \href{http://manpagesfr.free.fr/man/man2/clone.2.html}{constantes}.

\newpage
\subsection{Déclaration de clone(2)}
\begin{lstlisting}
#define _GNU_SOURCE
#include <sched.h>

int clone(int (*fn)(void *), void *stack, int flags, void *arg, ...
/* pid_t *parent_tid, void *tls, pid_t *child_tid */ );
\end{lstlisting}

\subsection{Historique}
Peut-être que Linux aurait dû avoir un appel système de création de threads - Linux aurait alors pu s'épargner la douleur de la première implémentation de pthread pour Linux. (Beaucoup d'erreurs ont été commises sur le chemin du NPTL.) Linux aurait dû apprendre de Solaris/SVR4, où l'émulation des sockets BSD via libsocket au-dessus de STREAMS s'est avérée être une erreur qui a pris beaucoup de temps et beaucoup d'argent à corriger . L'émulation d'une API à partir d'une autre API avec des décalages d'impédance est généralement au mieux difficile.
\\\\Depuis lors, clone(2) est devenu un couteau suisse - il a évolué pour avoir des fonctionnalités d'entrée dans les zones/prison, mais seulement en quelque sorte : Linux n'a pas de zones appropriées, à la place, Linux a ajouté de nouveaux drapeaux à clone(2) pour indiquer ce qui ne doit pas être partagé avec le parent. Et au fur et à mesure que de nouveaux drapeaux de clone(2) liés au conteneur furent ajoutés, les anciens codes ayant utilisé clone(2) pouvait souhaiter les avoir utilisés... il faudra modifier et reconstruire le monde appelant clone(2).


\subsection{Fonctionnement}
Quand le process enfant est créé par  la  fonction clone(), il  débute  son exécution  par un appel à la fonction vers laquelle pointe l'argument fn (cela est différent de fork(2), pour lequel l'exécution continue dans le process enfant à partir du moment de l'appel de fork(2)). L'argument 'arg' est passé comme argument de la fonction fn.
\\\\Quand la fonction fn(arg) renvoie, le process  enfant  se  termine. La  valeur  entière renvoyée  par  fn  est  utilisée comme code de retour du process enfant. Ce dernier peut également se terminer de manière explicite en invoquant la fonction exit(2)  ou  après  la réception d'un signal fatal.
\\\\L'argument  stack indique l'emplacement de la pile utilisée par le process enfant. Comme les process enfant et appelant peuvent partager de la mémoire, il n'est généralement pas possible  pour l'enfant d'utiliser la même pile que son parent. Le process appelant doit donc préparer un espace mémoire pour stocker la pile de son enfant, et transmettre à clone un  pointeur sur cet emplacement. Les piles croissent vers le bas sur tous les processeurs implémentant Linux (sauf le HP PA), donc stack doit pointer sur la plus haute  adresse  de l'espace  mémoire prévu pour la pile du process enfant. Pourtant, clone() ne fournit aucun moyen pour que l'appelant puisse informer le noyau de la taille de  la  zone  de  la pile.

\subsection{particularités}
L'appel  système  clone3()  fournit  un  sur-ensemble  de  la fonctionnalité de l'ancienne interface de clone(). Il offre également un certain nombre d'améliorations de l'API dont : un  espace  pour  des  bits d'attributs  supplémentaires, une séparation plus propre dans l'utilisation de plusieurs paramètres et la possibilité d'indiquer la taille de la zone de la pile de l'enfant.
\\\\Comme  avec fork(2), clone3() renvoie à la fois au parent et à l'enfant. Il renvoie 0 dans le process enfant et il renvoie le PID de l'enfant dans le parent.
\\\\Le paramètre cl\_args de clone3() est une structure ayant la forme suivante :

\begin{lstlisting}

struct clone_args {
               u64 flags;        /* Masque de bit d'attribut */
               u64 pidfd;        /* Où stocker le descripteur de fichier du PID
                                    (pid_t *) */
               u64 child_tid;    /* Où stocker le TID enfant,
                                    dans la mémoire de l'enfant's memory (pid_t *) */
               u64 parent_tid;   /* Où stocker le TID enfant,
                                    dans la mémoire du parent's memory (int *) */
               u64 exit_signal;  /* Signal à envoyer au parent quand
                                    l'efant se termine */
               u64 stack;        /* Pointeur vers l'octet le plus faible de la pile */
               u64 stack_size;   /* Taille de la pile */
               u64 tls;          /* Emplacement du nouveau TLS */
               u64 set_tid;      /* Pointeur vers un tableau pid_t
                                    (depuis Linux 5.5) */
               u64 set_tid_size; /* Nombre d'éléments dans set_tid
                                    (depuis Linux 5.5) */
               u64 cgroup;       /* Descripteur de fichier du cgroup cible
                                    de l'enfant (depuis Linux 5.7) */
           };
\end{lstlisting}
Le paramètre size fourni à clone3() doit être initialisé à la taille de  cette  structure (l'existence   du   paramètre  size  autorise  des  extensions  futures  de  la  structure clone\_args).
\\\\La pile du process enfant est indiquée avec cl\_args.stack, qui pointe  vers  l'octet  le plus faible de la zone de la pile, et avec cl\_args.stack\_size, qui indique la taille de la pile en octets. Si l'attribut CLONE\_VM est indiqué, une pile  doit  être explicitement allouée et indiquée. Sinon, ces deux champs peuvent valoir NULL et 0, ce qui amène l'enfant à utiliser la même zone de pile que son parent (dans  l'espace  d'adressage virtuel de son propre enfant).\\

\begin{large}
    Équivalence entre les paramètres de clone() et de clone3()
\end{large}
\begin{table}[ht]
\caption{clone() vs clone3()} % title of Table
\centering % used for centering table
\begin{tabular}{c c c } % centered columns (4 columns)
\hline\hline %inserts double horizontal lines
clone() & clone3() & Notes \\ [0.5ex] % inserts table
%heading
\hline % inserts single horizontal line
--- & Champ cl\_args &  \\ % inserting body of the table
attributs \& ~0xff & attributs & Pour la plupart des attributs ; détails ci-dessous \\
parent\_tid & pidfd & Voir CLONE\_PIDFD \\
child\_tid & child\_tid & Voir CLONE\_CHILD\_SETTID \\
parent\_tid & parent\_tid & Voir CLONE\_PARENT\_SETTID \\
child\_tid & child\_tid & Voir CLONE\_CHILD\_SETTID \\
attributs \& 0xff & exit\_signal \\
pile & pile \\
--- & stack\_size \\
tls & tls & Voir CLONE\_SETTLS \\
--- & set\_tid \\
--- & set\_tid\_size \\
--- & cgroup & Voir CLONE\_INTO\_CGROUP \\ [1ex] % [1ex] adds vertical space
\hline %inserts single line
\end{tabular}
\end{table}
\subsubsection{Signal de fin de l'enfant}
Quand  le  process enfant se termine, un signal peut être envoyé au parent. Le signal de fin  est  indiqué  dans  l'octet  de   poids   faible de   flags (clone())   ou   dans cl\_args.exit\_signal (clone3()). Si ce signal est différent de SIGCHLD, le process parent doit également spécifier les options  \_\_WALL  ou  \_\_WCLONE lorsqu'il  attend  la  fin  de l'enfant  avec  wait(2). Si aucun signal n'est indiqué (donc zéro), le process parent ne sera pas notifié de la terminaison de l'enfant.

\subsection{Problèmes éventuels}
Les versions de la bibliothèque C GNU jusqu'à la 2.24 comprise  contenaient  une  fonction enveloppe  pour  getpid(2) qui effectuait un cache des PID. Ce cache nécessitait une prise en charge par l'enveloppe de clone() de la glibc, mais des limites  dans  l'implémentation faisaient  que  le  cache  pouvait  ne  pas  être  à jour sous certaines circonstances. En particulier, si un signal était distribué à un enfant juste après l'appel à clone(), alors un  appel à getpid(2) dans le gestionnaire de signaux du signal pouvait renvoyer le PID du process appelant (le parent), si l'enveloppe de clone n'avait toujours pas eu  le temps de  mettre le cache de PID à jour pour l'enfant. (Ce point ignore le cas où l'enfant a été créé en utilisant CLONE\_THREAD, quand getpid(2) doit renvoyer la même valeur pour l'enfant et pour le process qui a appelé clone(), puisque l'appelant et l'enfant se trouvent dans le même groupe de threads. Ce problème de cache n'apparaît pas non plus  si  le  paramètre flags  contient  CLONE\_VM.)  Pour  obtenir  la  véritable  valeur, il peut être nécessaire d'utiliser quelque chose comme ceci :
\begin{lstlisting}
#include <syscall.h>

pid_t mypid;

mypid = syscall(SYS_getpid);
\end{lstlisting}
\textit{Donc, suite à un problème ancien de cache, ainsi qu'à d'autres problèmes traités dans getpid(2), la fonctionnalité de mise en cache du PID a été supprimée de la glibc 2.25.}
\subsection{Code}
\begin{normalsize}
Ce \hyperref[codeClone]{code} permet de dupliquer un process au moyen de l'appel système clone(). Grâce à option 'vm' entrée lors de l'exécution, l'espace d'adressage du père sera partagé avec le fils. Si cette option n'est pas précisée, le clone() ne se conduira pas comme l'appel système fork() mais comme l'appel système vfork().
\end{normalsize}

\newpage
\subsection{Résultats}
\subsubsection{./clone}
\begin{lstlisting}
Child sees buffer = "Hello from parent"
Child exited with status 0. buffer = "Hello from parent"
\end{lstlisting}

\subsubsection{./clone vm}
\begin{lstlisting}
Child sees buffer = "Hello from parent"
Child exited with status 0. buffer = "Hello from child"
\end{lstlisting}








%----------------------------------------------------------------------------------------
%	Aller plus loin
%----------------------------------------------------------------------------------------

\section{
    \LARGE
        Aller plus loin
}
L’ajout de la fonction forkall() au standard a été rejeté. La fonction
forkall() permet à tous les threads du parent d’être dupliqués dans l’enfant. 
Cela permet aux threads de l’enfant de poursuivre le traitement et permet
de préserver les verrous.


Le parent doit s’assurer que l’état de traitement des threads
partagé entre le parent et l’enfant se comporte correctement après forkall().

Par exemple, si un thread lit un descripteur de fichier dans le parent
lorsque forkall() est appelée, alors deux threads (un dans le parent et un dans l’enfant)
lisent le fichier filedescriptor après le forkall(). Si ce n’est pas un comportement
souhaité, le processus parent doit se synchroniser avec de tels threads avant
d’appeler forkall().

Les fonctions forkx() et forkallx() acceptent un argument flags constitué d'un OU inclusif bit à bit de zéro ou plus des drapeaux suivants, qui sont définis dans l'en-tête sys/fork.h
Si l’argument des flags est à 0, alors forkx() aura le même comportement que fork() et forkallx() aura le même comportement que forkall().






%----------------------------------------------------------------------------------------
%	Conclusion
%----------------------------------------------------------------------------------------

\section{
    \LARGE
        Conclusion
}
Pour finir, nous pouvons constater que fork() est vieux, mais encore utilisé également pour être enveloppé par des fonctions comme posix\_spawn() qui fait un fork()+exec(), que vfork() est dangereux et donc, de nouveau synonyme de fork() et que clone() est puissant car il permet de moduler la duplication de processus

%----------------------------------------------------------------------------------------
%	CODES
%----------------------------------------------------------------------------------------

\section{
    \LARGE
        Codes
}
\subsection{FORK}
\subsubsection{fork.c}
\inputminted[linenos, fontsize=\small, breaklines]{c}{codes/fork.c}\label{codeFork}

\subsubsection{forkMoreProcesses.c}
\inputminted[linenos, fontsize=\small, breaklines]{c}{codes/forkMoreProcesses.c}\label{codeForkMoreprocesses}


\newpage
\subsection{VFORK}
\subsubsection{vfork.c}
\inputminted[linenos, fontsize=\small, breaklines]{c}{codes/vfork.c}\label{codeVfork}

\subsubsection{vforkMoreProcesses.c}
\inputminted[linenos, fontsize=\small, breaklines]{c}{codes/vforkMoreProcesses.c}\label{codeVforkMoreprocesses}

\subsubsection{vforkParentPAUSED.c}
\inputminted[linenos, fontsize=\small, breaklines]{c}{codes/vforkParentPAUSED.c}\label{codeVforkParentPAUSED}


\newpage
\subsection{CLONE}
\subsubsection{clone.c}
\inputminted[linenos, fontsize=\small, breaklines]{c}{codes/clone.c}\label{codeClone}




%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\section{
    \LARGE
        Sources
}
\begin{sloppypar}
\url{https://cpp.hotexamples.com/fr/examples/-/-/vfork/cpp-vfork-function-examples.html}\\
\url{https://man7.org/linux/man-pages/man2/vfork.2.html}\\
\url{https://www.ibm.com/docs/en/SSLTBW_2.4.0/com.ibm.zos.v2r4.bpxbd00/rvfork.html}\\
\url{https://mindsgrid.com/difference-fork-vfork-exec-clone/}\\
\url{https://stackoverflow.com/questions/4856255/the-difference-between-fork-vfork-exec-and-clone}\\
\url{https://prograide.com/pregunta/11064/la-difference-entre-fork-vfork-exec-et-clonee}\\
\url{http://www.unixguide.net/unix/programming/1.1.2.shtml}\\
\url{https://prograide.com/pregunta/12758/differences-entre-exec-et-fourche}\\
\url{https://man7.org/linux/man-pages/man2/fork.2.html}\\
\url{https://techdifferences.com/difference-between-fork-and-vfork.html}\\
\url{https://www.ibm.com/docs/en/zos/2.4.0?topic=functions-vfork-create-new-process}\\
\url{https://man7.org/linux/man-pages/man2/fork.2.html}\\
\url{https://www.linuxjournal.com/article/5211}\\
\url{https://man7.org/linux/man-pages/man2/clone.2.html}\\
\url{http://www-igm.univ-mlv.fr/~dr/CS/node88.html}\\
\url{https://gist.github.com/nicowilliams/a8a07b0fc75df05f684c23c18d7db234}\\
\url{https://fresh2refresh.com/c-programming/c-buffer-manipulation-function/}\\
\url{https://stackoverflow.com/questions/66548922/can-a-fork-child-determine-whether-it-is-a-fork-or-a-vfork}\\
\url{https://news.ycombinator.com/item?id=30502392}\\
\url{https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/vfork.2.html}\\
\url{http://manpagesfr.free.fr/man/man2/clone.2.html}\\
\url{https://gist.github.com/alifarazz/d1ccf716131ed3a369fc7d248d910330}\\
\url{https://linux.die.net/man/2/clone}\\
\url{https://www.thegeekstuff.com/2012/05/c-mutex-examples/}\\
\url{https://docs.oracle.com/cd/E26502_01/html/E35303/gen-1.html}\\
\url{https://mindsgrid.com/difference-fork-vfork-exec-clone/}\\
\url{https://stackoverflow.com/questions/21205723/how-many-ways-we-can-create-a-process-in-linux-using-c}\\
\url{https://cpp.hotexamples.com/fr/examples/-/-/vfork/cpp-vfork-function-examples.html}\\
\url{https://man7.org/linux/man-pages/man2/vfork.2.html}\\
\url{https://www.ibm.com/docs/en/zos/2.4.0?topic=functions-vfork-create-new-process}\\
\url{https://mindsgrid.com/difference-fork-vfork-exec-clone/}\\
\url{https://stackoverflow.com/questions/4856255/the-difference-between-fork-vfork-exec-and-clone}\\
\url{https://prograide.com/pregunta/11064/la-difference-entre-fork-vfork-exec-et-clone}\\
\url{http://www.unixguide.net/unix/programming/1.1.2.shtml}\\
\url{https://prograide.com/pregunta/12758/differences-entre-exec-et-fourche}\\
\url{https://techdifferences.com/difference-between-fork-and-vfork.html}\\
\url{https://manpages.ubuntu.com/manpages/hirsute/fr/man2/clone.2.html}\\
\url{http://manpagesfr.free.fr/man/man2/clone.2.html}\\
\url{https://github.com/jeremyong/google-coredumper/issues/14}\\
\url{https://stackoverflow.com/questions/29264322/mmap-error-on-linux-using-somethingelse}\\
\url{https://man7.org/linux/man-pages/man7/signal.7.html}\\
\url{https://stackoverflow.com/questions/9361816/maximum-number-of-processes-in-linux}\\
\url{https://www.2daygeek.com/kill-terminate-a-process-in-linux-using-kill-pkill-killall-command/}\\
\url{https://www.baeldung.com/linux/fork-vfork-exec-clone}\\
\url{https://man7.org/linux/man-pages/man2/clone.2.html}\\
\end{sloppypar}

\end{sloppypar}
\end{document}